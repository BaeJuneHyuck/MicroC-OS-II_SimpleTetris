###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.2.214/W32 for ARM         23/Dec/2019  21:46:49
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        C:\Baby\test02\exam\ett\Micrium\Software\uCOS-II\Source\os_core.c
#    Command line =
#        -f C:\Users\hn829\AppData\Local\Temp\EW8F9D.tmp
#        (C:\Baby\test02\exam\ett\Micrium\Software\uCOS-II\Source\os_core.c
#        -lCN
#        C:\Baby\test02\exam\ett\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\List
#        -o
#        C:\Baby\test02\exam\ett\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\Obj
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.3\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Baby\test02\exam\ett\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\
#        -I
#        C:\Baby\test02\exam\ett\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\ucos-ii\ports\arm-cortex-m3\generic\iar\
#        -I
#        C:\Baby\test02\exam\ett\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\ucos-ii\source\
#        -I
#        C:\Baby\test02\exam\ett\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uc-lib\
#        -I
#        C:\Baby\test02\exam\ett\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uc-cpu\
#        -I
#        C:\Baby\test02\exam\ett\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uc-cpu\ARM-Cortex-M3\IAR\
#        -I
#        C:\Baby\test02\exam\ett\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\cpu\st\stm32\inc\
#        -I
#        C:\Baby\test02\exam\ett\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\BSP\
#        -I
#        C:\Baby\test02\exam\ett\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Source\
#        -I
#        C:\Baby\test02\exam\ett\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\ST\STM32\
#        -I
#        C:\Baby\test02\exam\ett\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Communication\Generic\Source\
#        -I
#        C:\Baby\test02\exam\ett\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Plugins\uCOS-II\
#        -Ohz --use_c++_inline)
#    Locale       =  C
#    List file    =
#        C:\Baby\test02\exam\ett\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\List\os_core.lst
#    Object file  =
#        C:\Baby\test02\exam\ett\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\Obj\os_core.o
#
###############################################################################

C:\Baby\test02\exam\ett\Micrium\Software\uCOS-II\Source\os_core.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/OS-II
      4          *                                          The Real-Time Kernel
      5          *                                             CORE FUNCTIONS
      6          *
      7          *                              (c) Copyright 1992-2007, Micrium, Weston, FL
      8          *                                           All Rights Reserved
      9          *
     10          * File    : OS_CORE.C
     11          * By      : Jean J. Labrosse
     12          * Version : V2.86
     13          *
     14          * LICENSING TERMS:
     15          * ---------------
     16          *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.  
     17          * If you plan on using  uC/OS-II  in a commercial product you need to contact Micriµm to properly license 
     18          * its use in your product. We provide ALL the source code for your convenience and to help you experience 
     19          * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a 
     20          * licensing fee.
     21          *********************************************************************************************************
     22          */
     23          
     24          #ifndef  OS_MASTER_FILE
     25          #define  OS_GLOBALS
     26          #include <ucos_ii.h>

   \                                 In section .bss, align 4
   \   __absolute INT8U OSCPUUsage
   \                     OSCPUUsage:
   \        0x0                      DS8 1
   \   __absolute BOOLEAN OSStatRdy
   \                     OSStatRdy:
   \        0x1                      DS8 1
   \   __absolute INT8U OSIntNesting
   \                     OSIntNesting:
   \        0x2                      DS8 1
   \   __absolute INT8U OSLockNesting
   \                     OSLockNesting:
   \        0x3                      DS8 1
   \   __absolute INT8U OSPrioCur
   \                     OSPrioCur:
   \        0x4                      DS8 1
   \   __absolute INT8U OSPrioHighRdy
   \                     OSPrioHighRdy:
   \        0x5                      DS8 1
   \   __absolute INT8U OSRdyGrp
   \                     OSRdyGrp:
   \        0x6                      DS8 1
   \   __absolute BOOLEAN OSRunning
   \                     OSRunning:
   \        0x7                      DS8 1
   \   __absolute INT8U OSTaskCtr
   \                     OSTaskCtr:
   \        0x8                      DS8 1
   \   __absolute INT8U OSTickStepState
   \                     OSTickStepState:
   \        0x9                      DS8 1
   \        0xA                      DS8 2
   \   __absolute INT8U OSRdyTbl[4]
   \                     OSRdyTbl:
   \        0xC                      DS8 4
   \   __absolute INT32U OSCtxSwCtr
   \                     OSCtxSwCtr:
   \       0x10                      DS8 4
   \   __absolute OS_EVENT *OSEventFreeList
   \                     OSEventFreeList:
   \       0x14                      DS8 4
   \   __absolute INT32U OSIdleCtrMax
   \                     OSIdleCtrMax:
   \       0x18                      DS8 4
   \   __absolute INT32U OSIdleCtrRun
   \                     OSIdleCtrRun:
   \       0x1C                      DS8 4
   \   __absolute INT32U volatile OSIdleCtr
   \                     OSIdleCtr:
   \       0x20                      DS8 4
   \   __absolute OS_TCB *OSTCBCur
   \                     OSTCBCur:
   \       0x24                      DS8 4
   \   __absolute OS_TCB *OSTCBFreeList
   \                     OSTCBFreeList:
   \       0x28                      DS8 4
   \   __absolute OS_TCB *OSTCBHighRdy
   \                     OSTCBHighRdy:
   \       0x2C                      DS8 4
   \   __absolute OS_TCB *OSTCBList
   \                     OSTCBList:
   \       0x30                      DS8 4
   \   __absolute INT32U volatile OSTime
   \                     OSTime:
   \       0x34                      DS8 4
   \   __absolute OS_EVENT OSEventTbl[10]
   \                     OSEventTbl:
   \       0x38                      DS8 320
   \   __absolute OS_STK OSTaskStatStk[128]
   \                     OSTaskStatStk:
   \      0x178                      DS8 512
   \   __absolute OS_STK OSTaskIdleStk[128]
   \                     OSTaskIdleStk:
   \      0x378                      DS8 512
   \   __absolute OS_TCB OSTCBTbl[22]
   \                     OSTCBTbl:
   \      0x578                      DS8 2'024

   \                                 In section .bss, align 4
   \   __absolute OS_FLAG_GRP OSFlagTbl[5]
   \                     OSFlagTbl:
   \        0x0                      DS8 140

   \                                 In section .bss, align 4
   \   __absolute OS_FLAG_GRP *OSFlagFreeList
   \                     OSFlagFreeList:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute OS_TCB *OSTCBPrioTbl[32]
   \                     OSTCBPrioTbl:
   \        0x0                      DS8 128
     27          #endif
     28          
     29          /*
     30          *********************************************************************************************************
     31          *                                       PRIORITY RESOLUTION TABLE
     32          *
     33          * Note: Index into table is bit pattern to resolve highest priority
     34          *       Indexed value corresponds to highest priority bit position (i.e. 0..7)
     35          *********************************************************************************************************
     36          */
     37          

   \                                 In section .rodata, align 4
     38          INT8U  const  OSUnMapTbl[256] = {
   \                     OSUnMapTbl:
   \        0x0   0x00 0x00          DC8 0, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x03 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x04 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01         
   \       0x17   0x00 0x03          DC8 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x05    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x03    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00         
   \       0x2E   0x01 0x00          DC8 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2
   \              0x04 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x03 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x06 0x00    
   \              0x01 0x00    
   \              0x02         
   \       0x45   0x00 0x01          DC8 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0
   \              0x00 0x03    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x04    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x03    
   \              0x00 0x01    
   \              0x00         
   \       0x5C   0x02 0x00          DC8 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1
   \              0x01 0x00    
   \              0x05 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x03 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x04 0x00    
   \              0x01         
   \       0x73   0x00 0x02          DC8 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 7, 0, 1, 0, 2, 0, 1, 0, 3, 0
   \              0x00 0x01    
   \              0x00 0x03    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x07    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x03    
   \              0x00         
   \       0x8A   0x01 0x00          DC8 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x04 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x03 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x05         
   \       0xA1   0x00 0x01          DC8 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x03    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x04    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00         
   \       0xB8   0x03 0x00          DC8 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x06 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x03 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01         
   \       0xCF   0x00 0x04          DC8 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x03    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x05    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00         
   \       0xE6   0x01 0x00          DC8 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2
   \              0x03 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x04 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x03 0x00    
   \              0x01 0x00    
   \              0x02         
   \       0xFD   0x00 0x01          DC8 0, 1, 0
   \              0x00         
     39              0, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x00 to 0x0F                             */
     40              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x10 to 0x1F                             */
     41              5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x20 to 0x2F                             */
     42              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x30 to 0x3F                             */
     43              6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x40 to 0x4F                             */
     44              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x50 to 0x5F                             */
     45              5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x60 to 0x6F                             */
     46              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x70 to 0x7F                             */
     47              7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x80 to 0x8F                             */
     48              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x90 to 0x9F                             */
     49              5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0xA0 to 0xAF                             */
     50              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0xB0 to 0xBF                             */
     51              6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0xC0 to 0xCF                             */
     52              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0xD0 to 0xDF                             */
     53              5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0xE0 to 0xEF                             */
     54              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0        /* 0xF0 to 0xFF                             */
     55          };
     56          
     57          /*$PAGE*/
     58          /*
     59          *********************************************************************************************************
     60          *                                       FUNCTION PROTOTYPES
     61          *********************************************************************************************************
     62          */
     63          
     64          static  void  OS_InitEventList(void);
     65          
     66          static  void  OS_InitMisc(void);
     67          
     68          static  void  OS_InitRdyList(void);
     69          
     70          static  void  OS_InitTaskIdle(void);
     71          
     72          #if OS_TASK_STAT_EN > 0
     73          static  void  OS_InitTaskStat(void);
     74          #endif
     75          
     76          static  void  OS_InitTCBList(void);
     77          
     78          static  void  OS_SchedNew(void);
     79          
     80          /*$PAGE*/
     81          /*
     82          *********************************************************************************************************
     83          *                         GET THE NAME OF A SEMAPHORE, MUTEX, MAILBOX or QUEUE
     84          *
     85          * Description: This function is used to obtain the name assigned to a semaphore, mutex, mailbox or queue.
     86          *
     87          * Arguments  : pevent    is a pointer to the event group.  'pevent' can point either to a semaphore,
     88          *                        a mutex, a mailbox or a queue.  Where this function is concerned, the actual
     89          *                        type is irrelevant.
     90          *
     91          *              pname     is a pointer to an ASCII string that will receive the name of the semaphore,
     92          *                        mutex, mailbox or queue.  The string must be able to hold at least
     93          *                        OS_EVENT_NAME_SIZE characters.
     94          *
     95          *              perr      is a pointer to an error code that can contain one of the following values:
     96          *
     97          *                        OS_ERR_NONE                if the name was copied to 'pname'
     98          *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to the proper event
     99          *                                                   control block type.
    100          *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
    101          *                        OS_ERR_PEVENT_NULL         if you passed a NULL pointer for 'pevent'
    102          *                        OS_ERR_NAME_GET_ISR        if you are trying to call this function from an ISR
    103          *
    104          * Returns    : The length of the string or 0 if the 'pevent' is a NULL pointer.
    105          *********************************************************************************************************
    106          */
    107          
    108          #if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)

   \                                 In section .text, align 2, keep-with-next
    109          INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
    110          {
   \                     OSEventNameGet: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x....'....        BL       ?Subroutine2
    111              INT8U      len;
    112          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    113              OS_CPU_SR  cpu_sr = 0;
    114          #endif
    115          
    116          
    117          
    118          #if OS_ARG_CHK_EN > 0
    119              if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
    120                  return (0);
    121              }
    122              if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
    123                  *perr = OS_ERR_PEVENT_NULL;
    124                  return (0);
    125              }
    126              if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
    127                  *perr = OS_ERR_PNAME_NULL;
    128                  return (0);
    129              }
    130          #endif
    131              if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
   \                     ??CrossCallReturnLabel_0: (+1)
   \        0x6   0xB108             CBZ.N    R0,??OSEventNameGet_0
    132                  *perr  = OS_ERR_NAME_GET_ISR;
   \        0x8   0x2111             MOVS     R1,#+17
   \        0xA   0xE014             B.N      ??OSEventNameGet_1
    133                  return (0);
    134              }
    135              switch (pevent->OSEventType) {
   \                     ??OSEventNameGet_0: (+1)
   \        0xC   0x7828             LDRB     R0,[R5, #+0]
   \        0xE   0x1E40             SUBS     R0,R0,#+1
   \       0x10   0x2803             CMP      R0,#+3
   \       0x12   0xD80F             BHI.N    ??OSEventNameGet_2
    136                  case OS_EVENT_TYPE_SEM:
    137                  case OS_EVENT_TYPE_MUTEX:
    138                  case OS_EVENT_TYPE_MBOX:
    139                  case OS_EVENT_TYPE_Q:
    140                       break;
    141          
    142                  default:
    143                       *perr = OS_ERR_EVENT_TYPE;
    144                       return (0);
    145              }
    146              OS_ENTER_CRITICAL();
   \       0x14   0x....'....        BL       OS_CPU_SR_Save
   \       0x18   0x4607             MOV      R7,R0
    147              len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
   \       0x1A   0xF105 0x010F      ADD      R1,R5,#+15
   \       0x1E   0x4630             MOV      R0,R6
   \       0x20   0x....'....        BL       OS_StrCopy
   \       0x24   0x4605             MOV      R5,R0
    148              OS_EXIT_CRITICAL();
   \       0x26   0x4638             MOV      R0,R7
   \       0x28   0x....'....        BL       OS_CPU_SR_Restore
    149              *perr = OS_ERR_NONE;
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0x7020             STRB     R0,[R4, #+0]
    150              return (len);
   \       0x30   0x4628             MOV      R0,R5
   \       0x32   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??OSEventNameGet_2: (+1)
   \       0x34   0x2101             MOVS     R1,#+1
   \                     ??OSEventNameGet_1: (+1)
   \       0x36   0x7021             STRB     R1,[R4, #+0]
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    151          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x460E             MOV      R6,R1
   \        0x2   0x....'....        LDR.W    R1,??DataTable20
   \        0x6   0x4605             MOV      R5,R0
   \        0x8   0x7888             LDRB     R0,[R1, #+2]
   \        0xA   0x4614             MOV      R4,R2
   \        0xC   0x4770             BX       LR
    152          #endif
    153          
    154          /*$PAGE*/
    155          /*
    156          *********************************************************************************************************
    157          *                         ASSIGN A NAME TO A SEMAPHORE, MUTEX, MAILBOX or QUEUE
    158          *
    159          * Description: This function assigns a name to a semaphore, mutex, mailbox or queue.
    160          *
    161          * Arguments  : pevent    is a pointer to the event group.  'pevent' can point either to a semaphore,
    162          *                        a mutex, a mailbox or a queue.  Where this function is concerned, it doesn't
    163          *                        matter the actual type.
    164          *
    165          *              pname     is a pointer to an ASCII string that will be used as the name of the semaphore,
    166          *                        mutex, mailbox or queue.  The string must be able to hold at least
    167          *                        OS_EVENT_NAME_SIZE characters.
    168          *
    169          *              perr      is a pointer to an error code that can contain one of the following values:
    170          *
    171          *                        OS_ERR_NONE                if the requested task is resumed
    172          *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to the proper event
    173          *                                                   control block type.
    174          *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
    175          *                        OS_ERR_PEVENT_NULL         if you passed a NULL pointer for 'pevent'
    176          *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
    177          *
    178          * Returns    : None
    179          *********************************************************************************************************
    180          */
    181          
    182          #if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)

   \                                 In section .text, align 2, keep-with-next
    183          void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
    184          {
   \                     OSEventNameSet: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x....'....        BL       ?Subroutine2
    185              INT8U      len;
    186          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    187              OS_CPU_SR  cpu_sr = 0;
    188          #endif
    189          
    190          
    191          
    192          #if OS_ARG_CHK_EN > 0
    193              if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
    194                  return;
    195              }
    196              if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
    197                  *perr = OS_ERR_PEVENT_NULL;
    198                  return;
    199              }
    200              if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
    201                  *perr = OS_ERR_PNAME_NULL;
    202                  return;
    203              }
    204          #endif
    205              if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
   \                     ??CrossCallReturnLabel_1: (+1)
   \        0x6   0xB108             CBZ.N    R0,??OSEventNameSet_0
    206                  *perr = OS_ERR_NAME_SET_ISR;
   \        0x8   0x2112             MOVS     R1,#+18
   \        0xA   0xE011             B.N      ??OSEventNameSet_1
    207                  return;
    208              }
    209              switch (pevent->OSEventType) {
   \                     ??OSEventNameSet_0: (+1)
   \        0xC   0x7828             LDRB     R0,[R5, #+0]
   \        0xE   0x1E40             SUBS     R0,R0,#+1
   \       0x10   0x2803             CMP      R0,#+3
   \       0x12   0xD80C             BHI.N    ??OSEventNameSet_2
    210                  case OS_EVENT_TYPE_SEM:
    211                  case OS_EVENT_TYPE_MUTEX:
    212                  case OS_EVENT_TYPE_MBOX:
    213                  case OS_EVENT_TYPE_Q:
    214                       break;
    215          
    216                  default:
    217                       *perr = OS_ERR_EVENT_TYPE;
    218                       return;
    219              }
    220              OS_ENTER_CRITICAL();
   \       0x14   0x....'....        BL       OS_CPU_SR_Save
   \       0x18   0x4607             MOV      R7,R0
    221              len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
    222              if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
   \       0x1A   0x4630             MOV      R0,R6
   \       0x1C   0x....'....        BL       OS_StrLen
   \       0x20   0x280F             CMP      R0,#+15
   \       0x22   0xDD07             BLE.N    ??OSEventNameSet_3
    223                  OS_EXIT_CRITICAL();
   \       0x24   0x4638             MOV      R0,R7
   \       0x26   0x....'....        BL       OS_CPU_SR_Restore
    224                  *perr = OS_ERR_EVENT_NAME_TOO_LONG;
   \       0x2A   0x200B             MOVS     R0,#+11
   \       0x2C   0xE00B             B.N      ??OSEventNameSet_4
    225                  return;
    226              }
   \                     ??OSEventNameSet_2: (+1)
   \       0x2E   0x2101             MOVS     R1,#+1
   \                     ??OSEventNameSet_1: (+1)
   \       0x30   0x7021             STRB     R1,[R4, #+0]
   \       0x32   0xBDF1             POP      {R0,R4-R7,PC}
    227              (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
   \                     ??OSEventNameSet_3: (+1)
   \       0x34   0x4631             MOV      R1,R6
   \       0x36   0xF105 0x000F      ADD      R0,R5,#+15
   \       0x3A   0x....'....        BL       OS_StrCopy
    228              OS_EXIT_CRITICAL();
   \       0x3E   0x4638             MOV      R0,R7
   \       0x40   0x....'....        BL       OS_CPU_SR_Restore
    229              *perr = OS_ERR_NONE;
   \       0x44   0x2000             MOVS     R0,#+0
   \                     ??OSEventNameSet_4: (+1)
   \       0x46   0x7020             STRB     R0,[R4, #+0]
    230          }
   \       0x48   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    231          #endif
    232          
    233          /*$PAGE*/
    234          /*
    235          *********************************************************************************************************
    236          *                                      PEND ON MULTIPLE EVENTS
    237          *
    238          * Description: This function waits for multiple events.  If multiple events are ready at the start of the
    239          *              pend call, then all available events are returned as ready.  If the task must pend on the
    240          *              multiple events, then only the first posted or aborted event is returned as ready.
    241          *
    242          * Arguments  : pevents_pend  is a pointer to a NULL-terminated array of event control blocks to wait for.
    243          *
    244          *              pevents_rdy   is a pointer to an array to return which event control blocks are available
    245          *                            or ready.  The size of the array MUST be greater than or equal to the size
    246          *                            of the 'pevents_pend' array, including terminating NULL.
    247          *
    248          *              pmsgs_rdy     is a pointer to an array to return messages from any available message-type
    249          *                            events.  The size of the array MUST be greater than or equal to the size of
    250          *                            the 'pevents_pend' array, excluding the terminating NULL.  Since NULL
    251          *                            messages are valid messages, this array cannot be NULL-terminated.  Instead,
    252          *                            every available message-type event returns its messages in the 'pmsgs_rdy'
    253          *                            array at the same index as the event is returned in the 'pevents_rdy' array.
    254          *                            All other 'pmsgs_rdy' array indices are filled with NULL messages.
    255          *
    256          *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
    257          *                            wait for the resources up to the amount of time specified by this argument.
    258          *                            If you specify 0, however, your task will wait forever for the specified
    259          *                            events or, until the resources becomes available (or the events occur).
    260          *
    261          *              perr          is a pointer to where an error message will be deposited.  Possible error
    262          *                            messages are:
    263          *
    264          *                            OS_ERR_NONE         The call was successful and your task owns the resources
    265          *                                                or, the events you are waiting for occurred; check the
    266          *                                                'pevents_rdy' array for which events are available.
    267          *                            OS_ERR_PEND_ABORT   The wait on the events was aborted; check the
    268          *                                                'pevents_rdy' array for which events were aborted.
    269          *                            OS_ERR_TIMEOUT      The events were not received within the specified
    270          *                                                'timeout'.
    271          *                            OS_ERR_PEVENT_NULL  If 'pevents_pend', 'pevents_rdy', or 'pmsgs_rdy' is a 
    272          *                                                NULL pointer.
    273          *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to an array of semaphores, 
    274          *                                                mailboxes, and/or queues.
    275          *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
    276          *                                                would lead to a suspension.
    277          *                            OS_ERR_PEND_LOCKED  If you called this function when the scheduler is locked.
    278          *
    279          * Returns    : >  0          the number of events returned as ready or aborted.
    280          *              == 0          if no events are returned as ready because of timeout or upon error.
    281          *
    282          * Notes      : 1) a. Validate 'pevents_pend' array as valid OS_EVENTs : 
    283          *
    284          *                        semaphores, mailboxes, queues
    285          *
    286          *                 b. Return ALL available events and messages, if any
    287          *
    288          *                 c. Add    current task priority as pending to   each events's wait list
    289          *                      Performed in OS_EventTaskWaitMulti()
    290          *
    291          *                 d. Wait on any of multiple events
    292          *
    293          *                 e. Remove current task priority as pending from each events's wait list
    294          *                      Performed in OS_EventTaskRdy(), if events posted or aborted
    295          *
    296          *                 f. Return any event posted or aborted, if any
    297          *                      else
    298          *                    Return timeout
    299          *
    300          *              2) 'pevents_rdy' initialized to NULL PRIOR to all other validation or function handling in 
    301          *                 case of any error(s).
    302          *********************************************************************************************************
    303          */
    304          /*$PAGE*/
    305          #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))

   \                                 In section .text, align 2, keep-with-next
    306          INT16U  OSEventPendMulti (OS_EVENT **pevents_pend, OS_EVENT **pevents_rdy, void **pmsgs_rdy, INT16U timeout, INT8U *perr)
    307          {
   \                     OSEventPendMulti: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x4680             MOV      R8,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x9F0C             LDR      R7,[SP, #+48]
    308              OS_EVENT  **pevents;
    309              OS_EVENT   *pevent;
    310          #if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
    311              OS_Q       *pq;
    312          #endif
    313              BOOLEAN     events_rdy;
    314              INT16U      events_rdy_nbr;
    315              INT8U       events_stat;
    316          #if (OS_CRITICAL_METHOD == 3)                           /* Allocate storage for CPU status register    */
    317              OS_CPU_SR   cpu_sr = 0;
    318          #endif
    319          
    320          
    321          
    322          #if (OS_ARG_CHK_EN > 0)
    323              if (perr == (INT8U *)0) {                           /* Validate 'perr'                             */
    324                  return (0);
    325              }
    326              if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
    327                 *perr =  OS_ERR_PEVENT_NULL;
    328                  return (0);
    329              }
    330              if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
    331                 *perr =  OS_ERR_PEVENT_NULL;
    332                  return (0);
    333              }
    334              if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
    335                 *perr =  OS_ERR_PEVENT_NULL;
    336                  return (0);
    337              }
    338          #endif
    339          
    340             *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x6028             STR      R0,[R5, #+0]
    341          
    342              pevents     =  pevents_pend;
   \        0xE   0x4641             MOV      R1,R8
   \       0x10   0x4691             MOV      R9,R2
    343              pevent      = *pevents;
   \       0x12   0x6808             LDR      R0,[R1, #+0]
   \       0x14   0xE001             B.N      ??OSEventPendMulti_0
    344              while  (pevent != (OS_EVENT *)0) {
    345                  switch (pevent->OSEventType) {                  /* Validate event block types                  */
    346          #if (OS_SEM_EN  > 0)
    347                      case OS_EVENT_TYPE_SEM:
    348                           break;
    349          #endif
    350          #if (OS_MBOX_EN > 0)
    351                      case OS_EVENT_TYPE_MBOX:
    352                           break;
    353          #endif
    354          #if ((OS_Q_EN   > 0) && (OS_MAX_QS > 0))
    355                      case OS_EVENT_TYPE_Q:
    356                           break;
    357          #endif
    358          
    359                      case OS_EVENT_TYPE_MUTEX:                                            
    360                      case OS_EVENT_TYPE_FLAG:
    361                      default:           
    362                          *perr = OS_ERR_EVENT_TYPE;
    363                           return (0);
    364                  }
    365                  pevents++;
    366                  pevent = *pevents;
   \                     ??OSEventPendMulti_1: (+1)
   \       0x16   0xF851 0x0F04      LDR      R0,[R1, #+4]!
   \                     ??OSEventPendMulti_0: (+1)
   \       0x1A   0xB130             CBZ.N    R0,??OSEventPendMulti_2
   \       0x1C   0x7800             LDRB     R0,[R0, #+0]
   \       0x1E   0x2801             CMP      R0,#+1
   \       0x20   0xBF18             IT       NE 
   \       0x22   0x2803             CMPNE    R0,#+3
   \       0x24   0xD0F7             BEQ.N    ??OSEventPendMulti_1
   \       0x26   0x2101             MOVS     R1,#+1
   \       0x28   0xE008             B.N      ??OSEventPendMulti_3
    367              }
    368          
    369              if (OSIntNesting  > 0) {                            /* See if called from ISR ...                  */
   \                     ??OSEventPendMulti_2: (+1)
   \       0x2A   0x....'....        LDR.W    R6,??DataTable20
   \       0x2E   0x78B0             LDRB     R0,[R6, #+2]
   \       0x30   0xB108             CBZ.N    R0,??OSEventPendMulti_4
    370                 *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
   \       0x32   0x2102             MOVS     R1,#+2
   \       0x34   0xE002             B.N      ??OSEventPendMulti_3
    371                  return (0);
    372              }
    373              if (OSLockNesting > 0) {                            /* See if called with scheduler locked ...     */
   \                     ??OSEventPendMulti_4: (+1)
   \       0x36   0x78F0             LDRB     R0,[R6, #+3]
   \       0x38   0xB118             CBZ.N    R0,??OSEventPendMulti_5
    374                 *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
   \       0x3A   0x210D             MOVS     R1,#+13
   \                     ??OSEventPendMulti_3: (+1)
   \       0x3C   0x7039             STRB     R1,[R7, #+0]
    375                  return (0);
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0xE0A1             B.N      ??OSEventPendMulti_6
    376              }
    377          
    378          /*$PAGE*/
    379              OS_ENTER_CRITICAL();
   \                     ??OSEventPendMulti_5: (+1)
   \       0x42   0x....'....        BL       OS_CPU_SR_Save
   \       0x46   0x4683             MOV      R11,R0
    380              events_rdy     =  OS_FALSE;
   \       0x48   0x2300             MOVS     R3,#+0
    381              events_rdy_nbr =  0;
    382              events_stat    =  OS_STAT_RDY;
    383              pevents        =  pevents_pend;
    384              pevent         = *pevents;
   \       0x4A   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x4E   0x469A             MOV      R10,R3
   \       0x50   0x2200             MOVS     R2,#+0
   \       0x52   0x4644             MOV      R4,R8
   \       0x54   0xE00E             B.N      ??OSEventPendMulti_7
    385              while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
    386                  switch (pevent->OSEventType) {
    387          #if (OS_SEM_EN > 0)
    388                      case OS_EVENT_TYPE_SEM:
    389                           if (pevent->OSEventCnt > 0) {          /* If semaphore count > 0, resource available; */
    390                               pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
   \                     ??OSEventPendMulti_8: (+1)
   \       0x56   0x1E49             SUBS     R1,R1,#+1
   \       0x58   0x8101             STRH     R1,[R0, #+8]
    391                              *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
   \       0x5A   0xF845 0x0B04      STR      R0,[R5], #+4
    392                                events_rdy   =  OS_TRUE;
   \       0x5E   0x2301             MOVS     R3,#+1
    393                              *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
   \       0x60   0x2000             MOVS     R0,#+0
   \       0x62   0xF849 0x0B04      STR      R0,[R9], #+4
    394                                events_rdy_nbr++;
   \                     ??OSEventPendMulti_9: (+1)
   \       0x66   0xF8BD 0xA000      LDRH     R10,[SP, #+0]
   \       0x6A   0xE001             B.N      ??OSEventPendMulti_10
    395          
    396                           } else {
    397                                events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
    398                           }
    399                           break;
    400          #endif
    401          
    402          #if (OS_MBOX_EN > 0)
    403                      case OS_EVENT_TYPE_MBOX:
    404                           if (pevent->OSEventPtr != (void *)0) { /* If mailbox NOT empty;                   ... */
    405                                                                  /* ... return available message,           ... */
    406                              *pmsgs_rdy++         = (void *)pevent->OSEventPtr;
    407                               pevent->OSEventPtr  = (void *)0;
    408                              *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
    409                                events_rdy         =  OS_TRUE;
    410                                events_rdy_nbr++;
    411          
    412                           } else {
    413                                events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
   \                     ??OSEventPendMulti_11: (+1)
   \       0x6C   0xF042 0x0202      ORR      R2,R2,#0x2
    414                           }
    415                           break;
    416          #endif
    417          
    418          #if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
    419                      case OS_EVENT_TYPE_Q:
    420                           pq = (OS_Q *)pevent->OSEventPtr;
    421                           if (pq->OSQEntries > 0) {              /* If queue NOT empty;                     ... */
    422                                                                  /* ... return available message,           ... */
    423                              *pmsgs_rdy++ = (void *)*pq->OSQOut++;
    424                               if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
    425                                   pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
    426                               }
    427                               pq->OSQEntries--;                  /* Update number of queue entries              */
    428                              *pevents_rdy++ = pevent;            /* ... and return available queue event        */
    429                                events_rdy   = OS_TRUE;
    430                                events_rdy_nbr++;
    431          
    432                           } else {
    433                                events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
    434                           }
    435                           break;
    436          #endif
    437          
    438                      case OS_EVENT_TYPE_MUTEX:                                            
    439                      case OS_EVENT_TYPE_FLAG:
    440                      default:           
    441                           OS_EXIT_CRITICAL();
    442                          *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
    443                          *perr        =  OS_ERR_EVENT_TYPE;
    444                           return (events_rdy_nbr);
    445                  }
    446                  pevents++;
    447                  pevent = *pevents;
   \                     ??OSEventPendMulti_10: (+1)
   \       0x70   0xF854 0x0F04      LDR      R0,[R4, #+4]!
   \                     ??OSEventPendMulti_7: (+1)
   \       0x74   0xF10A 0x0101      ADD      R1,R10,#+1
   \       0x78   0xF8AD 0x1000      STRH     R1,[SP, #+0]
   \       0x7C   0xB1A8             CBZ.N    R0,??OSEventPendMulti_12
   \       0x7E   0x7801             LDRB     R1,[R0, #+0]
   \       0x80   0x2901             CMP      R1,#+1
   \       0x82   0xD007             BEQ.N    ??OSEventPendMulti_13
   \       0x84   0x2903             CMP      R1,#+3
   \       0x86   0xD15D             BNE.N    ??OSEventPendMulti_14
   \       0x88   0x8901             LDRH     R1,[R0, #+8]
   \       0x8A   0x2900             CMP      R1,#+0
   \       0x8C   0xD1E3             BNE.N    ??OSEventPendMulti_8
   \       0x8E   0xF042 0x0201      ORR      R2,R2,#0x1
   \       0x92   0xE7ED             B.N      ??OSEventPendMulti_10
   \                     ??OSEventPendMulti_13: (+1)
   \       0x94   0x6841             LDR      R1,[R0, #+4]
   \       0x96   0x2900             CMP      R1,#+0
   \       0x98   0xD0E8             BEQ.N    ??OSEventPendMulti_11
   \       0x9A   0xF849 0x1B04      STR      R1,[R9], #+4
   \       0x9E   0x2301             MOVS     R3,#+1
   \       0xA0   0x2100             MOVS     R1,#+0
   \       0xA2   0x6041             STR      R1,[R0, #+4]
   \       0xA4   0xF845 0x0B04      STR      R0,[R5], #+4
   \       0xA8   0xE7DD             B.N      ??OSEventPendMulti_9
    448              }
   \                     ??OSEventPendMulti_12: (+1)
   \       0xAA   0x2400             MOVS     R4,#+0
    449          
    450              if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
   \       0xAC   0xB123             CBZ.N    R3,??OSEventPendMulti_15
    451                 *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
   \       0xAE   0x6028             STR      R0,[R5, #+0]
    452                  OS_EXIT_CRITICAL();
   \       0xB0   0x....'....        BL       ?Subroutine3
    453                 *perr        =  OS_ERR_NONE;
   \                     ??CrossCallReturnLabel_5: (+1)
   \       0xB4   0x703C             STRB     R4,[R7, #+0]
    454                  return (events_rdy_nbr);
   \       0xB6   0xE065             B.N      ??CrossCallReturnLabel_2
    455              }
    456          /*$PAGE*/
    457                                                                  /* Otherwise, must wait until any event occurs */
    458              OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
    459                                         OS_STAT_MULTI;           /* ... pend on multiple events                 */
   \                     ??OSEventPendMulti_15: (+1)
   \       0xB8   0x6A71             LDR      R1,[R6, #+36]
   \       0xBA   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \       0xBE   0xF891 0x3030      LDRB     R3,[R1, #+48]
   \       0xC2   0xF042 0x0280      ORR      R2,R2,#0x80
   \       0xC6   0x431A             ORRS     R2,R2,R3
   \       0xC8   0xF881 0x2030      STRB     R2,[R1, #+48]
    460              OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
   \       0xCC   0x6A72             LDR      R2,[R6, #+36]
   \       0xCE   0xF882 0x4031      STRB     R4,[R2, #+49]
    461              OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
   \       0xD2   0x6A71             LDR      R1,[R6, #+36]
   \       0xD4   0x85C8             STRH     R0,[R1, #+46]
    462              OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
   \       0xD6   0x4640             MOV      R0,R8
   \       0xD8   0x....'....        BL       OS_EventTaskWaitMulti
    463          
    464              OS_EXIT_CRITICAL();
   \       0xDC   0x....'....        BL       ?Subroutine3
    465              OS_Sched();                                         /* Find next highest priority task ready       */
   \                     ??CrossCallReturnLabel_4: (+1)
   \       0xE0   0x....'....        BL       OS_Sched
    466              OS_ENTER_CRITICAL();
   \       0xE4   0x....'....        BL       OS_CPU_SR_Save
   \       0xE8   0x4683             MOV      R11,R0
    467          
    468              switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
   \       0xEA   0x6A70             LDR      R0,[R6, #+36]
   \       0xEC   0xF100 0x011C      ADD      R1,R0,#+28
   \       0xF0   0x7D4A             LDRB     R2,[R1, #+21]
   \       0xF2   0x2A00             CMP      R2,#+0
   \       0xF4   0xBF18             IT       NE 
   \       0xF6   0x2A02             CMPNE    R2,#+2
   \       0xF8   0xD10D             BNE.N    ??OSEventPendMulti_16
    469                  case OS_STAT_PEND_OK:
    470                  case OS_STAT_PEND_ABORT:
    471                       pevent = OSTCBCur->OSTCBEventPtr;
   \       0xFA   0x680C             LDR      R4,[R1, #+0]
    472                       if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
   \       0xFC   0xB134             CBZ.N    R4,??OSEventPendMulti_17
    473                          *pevents_rdy++ =  pevent;               /* ... return available event ...              */
   \       0xFE   0x602C             STR      R4,[R5, #+0]
    474                          *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
   \      0x100   0x2000             MOVS     R0,#+0
   \      0x102   0xF845 0x0F04      STR      R0,[R5, #+4]!
    475                            events_rdy_nbr++;
   \      0x106   0xF8BD 0xA000      LDRH     R10,[SP, #+0]
   \      0x10A   0xE007             B.N      ??OSEventPendMulti_18
    476          
    477                       } else {                                   /* Else NO event available, handle as timeout  */
    478                           OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
   \                     ??OSEventPendMulti_17: (+1)
   \      0x10C   0x2001             MOVS     R0,#+1
   \      0x10E   0x7548             STRB     R0,[R1, #+21]
    479                           OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
   \      0x110   0x4641             MOV      R1,R8
   \      0x112   0x6A70             LDR      R0,[R6, #+36]
   \      0x114   0xE000             B.N      ??OSEventPendMulti_19
    480                       }
    481          			 break;
    482          
    483                  case OS_STAT_PEND_TO:                           /* If events timed out, ...                    */
    484                  default:                                        /* ... remove task from events' wait lists     */
    485                       OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
   \                     ??OSEventPendMulti_16: (+1)
   \      0x116   0x4641             MOV      R1,R8
   \                     ??OSEventPendMulti_19: (+1)
   \      0x118   0x....'....        BL       OS_EventTaskRemoveMulti
    486                       break;
    487              }
    488          
    489              switch (OSTCBCur->OSTCBStatPend) {
   \                     ??OSEventPendMulti_18: (+1)
   \      0x11C   0x6A70             LDR      R0,[R6, #+36]
   \      0x11E   0x3024             ADDS     R0,R0,#+36
   \      0x120   0x7B41             LDRB     R1,[R0, #+13]
   \      0x122   0xB111             CBZ.N    R1,??OSEventPendMulti_20
   \      0x124   0x2902             CMP      R1,#+2
   \      0x126   0xD014             BEQ.N    ??OSEventPendMulti_21
   \      0x128   0xE019             B.N      ??OSEventPendMulti_22
    490                  case OS_STAT_PEND_OK:
    491                       switch (pevent->OSEventType) {             /* Return event's message                      */
   \                     ??OSEventPendMulti_20: (+1)
   \      0x12A   0x7822             LDRB     R2,[R4, #+0]
   \      0x12C   0x1E52             SUBS     R2,R2,#+1
   \      0x12E   0x2A01             CMP      R2,#+1
   \      0x130   0xD906             BLS.N    ??OSEventPendMulti_23
   \      0x132   0x1E92             SUBS     R2,R2,#+2
   \      0x134   0xD106             BNE.N    ??OSEventPendMulti_14
    492          #if (OS_SEM_EN > 0)
    493                           case OS_EVENT_TYPE_SEM:
    494                               *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
   \      0x136   0x2000             MOVS     R0,#+0
   \                     ??OSEventPendMulti_24: (+1)
   \      0x138   0xF849 0x0B04      STR      R0,[R9], #+4
    495                                break;
    496          #endif
    497          
    498          #if ((OS_MBOX_EN > 0) ||                 \
    499              ((OS_Q_EN    > 0) && (OS_MAX_QS > 0)))
    500                           case OS_EVENT_TYPE_MBOX:
    501                           case OS_EVENT_TYPE_Q:
    502                               *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
    503                                break;
    504          #endif
    505          
    506                           case OS_EVENT_TYPE_MUTEX:                                       
    507                           case OS_EVENT_TYPE_FLAG:
    508                           default:           
    509                                OS_EXIT_CRITICAL();
    510                               *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
    511                               *perr        =  OS_ERR_EVENT_TYPE;
    512                                return (events_rdy_nbr);
    513                       }
    514                      *perr = OS_ERR_NONE;
   \      0x13C   0x7039             STRB     R1,[R7, #+0]
    515                       break;
   \      0x13E   0xE013             B.N      ??OSEventPendMulti_25
   \                     ??OSEventPendMulti_23: (+1)
   \      0x140   0x6800             LDR      R0,[R0, #+0]
   \      0x142   0xE7F9             B.N      ??OSEventPendMulti_24
   \                     ??OSEventPendMulti_14: (+1)
   \      0x144   0x....'....        BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_3: (+1)
   \      0x148   0x2000             MOVS     R0,#+0
   \      0x14A   0x6028             STR      R0,[R5, #+0]
   \      0x14C   0x2101             MOVS     R1,#+1
   \      0x14E   0x7039             STRB     R1,[R7, #+0]
   \      0x150   0xE018             B.N      ??CrossCallReturnLabel_2
    516          
    517                  case OS_STAT_PEND_ABORT:
    518                      *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
   \                     ??OSEventPendMulti_21: (+1)
   \      0x152   0x2200             MOVS     R2,#+0
   \      0x154   0xF849 0x2B04      STR      R2,[R9], #+4
    519                      *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
   \      0x158   0x200E             MOVS     R0,#+14
   \      0x15A   0x7038             STRB     R0,[R7, #+0]
    520                       break;
   \      0x15C   0xE004             B.N      ??OSEventPendMulti_25
    521                                                                  
    522                  case OS_STAT_PEND_TO:                                                
    523                  default:        
    524                      *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
   \                     ??OSEventPendMulti_22: (+1)
   \      0x15E   0x2100             MOVS     R1,#+0
   \      0x160   0xF849 0x1B04      STR      R1,[R9], #+4
    525                      *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
   \      0x164   0x220A             MOVS     R2,#+10
   \      0x166   0x703A             STRB     R2,[R7, #+0]
    526                       break;
    527              }
    528          
    529              OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
   \                     ??OSEventPendMulti_25: (+1)
   \      0x168   0x2000             MOVS     R0,#+0
   \      0x16A   0x6A71             LDR      R1,[R6, #+36]
   \      0x16C   0xF881 0x0030      STRB     R0,[R1, #+48]
    530              OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
   \      0x170   0x6A71             LDR      R1,[R6, #+36]
   \      0x172   0xF881 0x0031      STRB     R0,[R1, #+49]
    531              OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
   \      0x176   0x2100             MOVS     R1,#+0
   \      0x178   0x6A70             LDR      R0,[R6, #+36]
   \      0x17A   0x61C1             STR      R1,[R0, #+28]
    532              OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
   \      0x17C   0x6201             STR      R1,[R0, #+32]
    533              OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
   \      0x17E   0x6241             STR      R1,[R0, #+36]
    534              OS_EXIT_CRITICAL();
   \      0x180   0x....'....        BL       ?Subroutine3
    535          
    536              return (events_rdy_nbr);
   \                     ??CrossCallReturnLabel_2: (+1)
   \      0x184   0x4650             MOV      R0,R10
   \                     ??OSEventPendMulti_6: (+1)
   \      0x186   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    537          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0x4658             MOV      R0,R11
   \        0x2   0x....'....        B.W      OS_CPU_SR_Restore
    538          #endif
    539          
    540          /*$PAGE*/
    541          /*
    542          *********************************************************************************************************
    543          *                                             INITIALIZATION
    544          *
    545          * Description: This function is used to initialize the internals of uC/OS-II and MUST be called prior to
    546          *              creating any uC/OS-II object and, prior to calling OSStart().
    547          *
    548          * Arguments  : none
    549          *
    550          * Returns    : none
    551          *********************************************************************************************************
    552          */
    553          

   \                                 In section .text, align 2, keep-with-next
    554          void  OSInit (void)
    555          {
   \                     OSInit: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB086             SUB      SP,SP,#+24
    556              OSInitHookBegin();                                           /* Call port specific initialization code   */
   \        0x4   0x....'....        BL       OSInitHookBegin
    557          
    558              OS_InitMisc();                                               /* Initialize miscellaneous variables       */
   \        0x8   0x....'....        LDR.W    R4,??DataTable20
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x6360             STR      R0,[R4, #+52]
   \       0x10   0x70A0             STRB     R0,[R4, #+2]
   \       0x12   0x70E0             STRB     R0,[R4, #+3]
   \       0x14   0x7220             STRB     R0,[R4, #+8]
   \       0x16   0x71E0             STRB     R0,[R4, #+7]
   \       0x18   0x6120             STR      R0,[R4, #+16]
   \       0x1A   0x6220             STR      R0,[R4, #+32]
   \       0x1C   0x61E0             STR      R0,[R4, #+28]
   \       0x1E   0x61A0             STR      R0,[R4, #+24]
   \       0x20   0x7060             STRB     R0,[R4, #+1]
    559          
    560              OS_InitRdyList();                                            /* Initialize the Ready List                */
   \       0x22   0x71A0             STRB     R0,[R4, #+6]
   \       0x24   0x2104             MOVS     R1,#+4
   \       0x26   0xF104 0x000C      ADD      R0,R4,#+12
   \       0x2A   0x....'....        BL       __aeabi_memclr
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x7120             STRB     R0,[R4, #+4]
   \       0x32   0x7160             STRB     R0,[R4, #+5]
   \       0x34   0x62E0             STR      R0,[R4, #+44]
   \       0x36   0x6260             STR      R0,[R4, #+36]
    561          
    562              OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
   \       0x38   0xF504 0x65AF      ADD      R5,R4,#+1400
   \       0x3C   0xF44F 0x61FD      MOV      R1,#+2024
   \       0x40   0x4628             MOV      R0,R5
   \       0x42   0x....'....        BL       OS_MemClr
   \       0x46   0x2180             MOVS     R1,#+128
   \       0x48   0x....'....        LDR.W    R0,??DataTable20_1
   \       0x4C   0x....'....        BL       OS_MemClr
   \       0x50   0x4629             MOV      R1,R5
   \       0x52   0xF204 0x52D4      ADDW     R2,R4,#+1492
   \       0x56   0x2015             MOVS     R0,#+21
   \       0x58   0x263F             MOVS     R6,#+63
   \       0x5A   0x2700             MOVS     R7,#+0
   \                     ??OSInit_0: (+1)
   \       0x5C   0xF101 0x034C      ADD      R3,R1,#+76
   \       0x60   0x614A             STR      R2,[R1, #+20]
   \       0x62   0x315C             ADDS     R1,R1,#+92
   \       0x64   0x325C             ADDS     R2,R2,#+92
   \       0x66   0x1E40             SUBS     R0,R0,#+1
   \       0x68   0x701E             STRB     R6,[R3, #+0]
   \       0x6A   0x705F             STRB     R7,[R3, #+1]
   \       0x6C   0xD1F6             BNE.N    ??OSInit_0
   \       0x6E   0x6148             STR      R0,[R1, #+20]
   \       0x70   0xF101 0x004C      ADD      R0,R1,#+76
   \       0x74   0x7006             STRB     R6,[R0, #+0]
   \       0x76   0x7047             STRB     R7,[R0, #+1]
   \       0x78   0x6327             STR      R7,[R4, #+48]
   \       0x7A   0x62A5             STR      R5,[R4, #+40]
    563          
    564              OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
   \       0x7C   0xF44F 0x71A0      MOV      R1,#+320
   \       0x80   0xF104 0x0038      ADD      R0,R4,#+56
   \       0x84   0x....'....        BL       OS_MemClr
   \       0x88   0xF104 0x0138      ADD      R1,R4,#+56
   \       0x8C   0xF104 0x0258      ADD      R2,R4,#+88
   \       0x90   0x2009             MOVS     R0,#+9
   \                     ??OSInit_1: (+1)
   \       0x92   0x700F             STRB     R7,[R1, #+0]
   \       0x94   0x604A             STR      R2,[R1, #+4]
   \       0x96   0x73CE             STRB     R6,[R1, #+15]
   \       0x98   0x740F             STRB     R7,[R1, #+16]
   \       0x9A   0x3120             ADDS     R1,R1,#+32
   \       0x9C   0x3220             ADDS     R2,R2,#+32
   \       0x9E   0x1E40             SUBS     R0,R0,#+1
   \       0xA0   0xD1F7             BNE.N    ??OSInit_1
   \       0xA2   0x7008             STRB     R0,[R1, #+0]
   \       0xA4   0x604F             STR      R7,[R1, #+4]
   \       0xA6   0x73CE             STRB     R6,[R1, #+15]
   \       0xA8   0x7408             STRB     R0,[R1, #+16]
   \       0xAA   0xF104 0x0138      ADD      R1,R4,#+56
   \       0xAE   0x6161             STR      R1,[R4, #+20]
    565          
    566          #if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    567              OS_FlagInit();                                               /* Initialize the event flag structures     */
   \       0xB0   0x....'....        BL       OS_FlagInit
    568          #endif
    569          
    570          #if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
    571              OS_MemInit();                                                /* Initialize the memory manager            */
    572          #endif
    573          
    574          #if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
    575              OS_QInit();                                                  /* Initialize the message queue structures  */
    576          #endif
    577          
    578              OS_InitTaskIdle();                                           /* Create the Idle Task                     */
   \       0xB4   0x2003             MOVS     R0,#+3
   \       0xB6   0x9004             STR      R0,[SP, #+16]
   \       0xB8   0x2280             MOVS     R2,#+128
   \       0xBA   0xF504 0x735E      ADD      R3,R4,#+888
   \       0xBE   0xF64F 0x70FF      MOVW     R0,#+65535
   \       0xC2   0x....'....        BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_11: (+1)
   \       0xC6   0x231F             MOVS     R3,#+31
   \       0xC8   0xF204 0x5274      ADDW     R2,R4,#+1396
   \       0xCC   0x....'....        ADR.W    R0,OS_TaskIdle
   \       0xD0   0x....'....        BL       OSTaskCreateExt
   \       0xD4   0xAA05             ADD      R2,SP,#+20
   \       0xD6   0x....'....        ADR.W    R1,?_0
   \       0xDA   0x201F             MOVS     R0,#+31
   \       0xDC   0x....'....        BL       OSTaskNameSet
    579          #if OS_TASK_STAT_EN > 0
    580              OS_InitTaskStat();                                           /* Create the Statistic Task                */
   \       0xE0   0x2003             MOVS     R0,#+3
   \       0xE2   0x9004             STR      R0,[SP, #+16]
   \       0xE4   0x2280             MOVS     R2,#+128
   \       0xE6   0xF504 0x73BC      ADD      R3,R4,#+376
   \       0xEA   0xF64F 0x70FE      MOVW     R0,#+65534
   \       0xEE   0x....'....        BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_12: (+1)
   \       0xF2   0x231E             MOVS     R3,#+30
   \       0xF4   0xF504 0x725D      ADD      R2,R4,#+884
   \       0xF8   0x....'....        ADR.W    R0,OS_TaskStat
   \       0xFC   0x....'....        BL       OSTaskCreateExt
   \      0x100   0xAA05             ADD      R2,SP,#+20
   \      0x102   0x....'....        ADR.W    R1,?_1
   \      0x106   0x201E             MOVS     R0,#+30
   \      0x108   0x....'....        BL       OSTaskNameSet
    581          #endif
    582          
    583          #if OS_TMR_EN > 0
    584              OSTmr_Init();                                                /* Initialize the Timer Manager             */
    585          #endif
    586          
    587              OSInitHookEnd();                                             /* Call port specific init. code            */
   \      0x10C   0x....'....        BL       OSInitHookEnd
    588          
    589          #if OS_DEBUG_EN > 0
    590              OSDebugInit();
   \      0x110   0x....'....        BL       OSDebugInit
    591          #endif
    592          }
   \      0x114   0xB007             ADD      SP,SP,#+28
   \      0x116   0xBDF0             POP      {R4-R7,PC}       ;; return
    593          /*$PAGE*/
    594          /*
    595          *********************************************************************************************************
    596          *                                              ENTER ISR
    597          *
    598          * Description: This function is used to notify uC/OS-II that you are about to service an interrupt
    599          *              service routine (ISR).  This allows uC/OS-II to keep track of interrupt nesting and thus
    600          *              only perform rescheduling at the last nested ISR.
    601          *
    602          * Arguments  : none
    603          *
    604          * Returns    : none
    605          *
    606          * Notes      : 1) This function should be called ith interrupts already disabled
    607          *              2) Your ISR can directly increment OSIntNesting without calling this function because
    608          *                 OSIntNesting has been declared 'global'.
    609          *              3) You MUST still call OSIntExit() even though you increment OSIntNesting directly.
    610          *              4) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call
    611          *                 to OSIntEnter() at the beginning of the ISR you MUST have a call to OSIntExit() at the
    612          *                 end of the ISR.
    613          *              5) You are allowed to nest interrupts up to 255 levels deep.
    614          *              6) I removed the OS_ENTER_CRITICAL() and OS_EXIT_CRITICAL() around the increment because
    615          *                 OSIntEnter() is always called with interrupts disabled.
    616          *********************************************************************************************************
    617          */
    618          

   \                                 In section .text, align 2, keep-with-next
    619          void  OSIntEnter (void)
    620          {
    621              if (OSRunning == OS_TRUE) {
   \                     OSIntEnter: (+1)
   \        0x0   0x....'....        LDR.W    R0,??DataTable20
   \        0x4   0x79C1             LDRB     R1,[R0, #+7]
   \        0x6   0x2901             CMP      R1,#+1
   \        0x8   0xD104             BNE.N    ??OSIntEnter_0
    622                  if (OSIntNesting < 255u) {
   \        0xA   0x7881             LDRB     R1,[R0, #+2]
   \        0xC   0x29FF             CMP      R1,#+255
   \        0xE   0xBF1C             ITT      NE 
   \       0x10   0x1C49             ADDNE    R1,R1,#+1
   \       0x12   0x7081             STRBNE   R1,[R0, #+2]
    623                      OSIntNesting++;                      /* Increment ISR nesting level                        */
    624                  }
    625              }
    626          }
   \                     ??OSIntEnter_0: (+1)
   \       0x14   0x4770             BX       LR               ;; return
    627          /*$PAGE*/
    628          /*
    629          *********************************************************************************************************
    630          *                                               EXIT ISR
    631          *
    632          * Description: This function is used to notify uC/OS-II that you have completed serviving an ISR.  When
    633          *              the last nested ISR has completed, uC/OS-II will call the scheduler to determine whether
    634          *              a new, high-priority task, is ready to run.
    635          *
    636          * Arguments  : none
    637          *
    638          * Returns    : none
    639          *
    640          * Notes      : 1) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call
    641          *                 to OSIntEnter() at the beginning of the ISR you MUST have a call to OSIntExit() at the
    642          *                 end of the ISR.
    643          *              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
    644          *********************************************************************************************************
    645          */
    646          

   \                                 In section .text, align 2, keep-with-next
    647          void  OSIntExit (void)
    648          {
   \                     OSIntExit: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    649          #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    650              OS_CPU_SR  cpu_sr = 0;
    651          #endif
    652          
    653          
    654          
    655              if (OSRunning == OS_TRUE) {
   \        0x2   0x....'....        BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_6: (+1)
   \        0x6   0xD11F             BNE.N    ??OSIntExit_0
    656                  OS_ENTER_CRITICAL();
   \        0x8   0x....'....        BL       OS_CPU_SR_Save
   \        0xC   0x4605             MOV      R5,R0
    657                  if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
   \        0xE   0x78A0             LDRB     R0,[R4, #+2]
   \       0x10   0xB108             CBZ.N    R0,??OSIntExit_1
    658                      OSIntNesting--;
   \       0x12   0x1E40             SUBS     R0,R0,#+1
   \       0x14   0x70A0             STRB     R0,[R4, #+2]
    659                  }
    660                  if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
    661                      if (OSLockNesting == 0) {                      /* ... and not locked.                      */
   \                     ??OSIntExit_1: (+1)
   \       0x16   0x78A1             LDRB     R1,[R4, #+2]
   \       0x18   0x78E0             LDRB     R0,[R4, #+3]
   \       0x1A   0x4301             ORRS     R1,R0,R1
   \       0x1C   0xD112             BNE.N    ??OSIntExit_2
    662                          OS_SchedNew();
   \       0x1E   0x....'....        BL       OS_SchedNew
    663                          if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
   \       0x22   0x7960             LDRB     R0,[R4, #+5]
   \       0x24   0x7921             LDRB     R1,[R4, #+4]
   \       0x26   0x4288             CMP      R0,R1
   \       0x28   0xD00C             BEQ.N    ??OSIntExit_2
    664                              OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
   \       0x2A   0x....'....        LDR.W    R2,??DataTable20_1
   \       0x2E   0xF852 0x0020      LDR      R0,[R2, R0, LSL #+2]
   \       0x32   0x62E0             STR      R0,[R4, #+44]
    665          #if OS_TASK_PROFILE_EN > 0
    666                              OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
   \       0x34   0x6B81             LDR      R1,[R0, #+56]
   \       0x36   0x1C49             ADDS     R1,R1,#+1
   \       0x38   0x6381             STR      R1,[R0, #+56]
    667          #endif
    668                              OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
   \       0x3A   0x6920             LDR      R0,[R4, #+16]
   \       0x3C   0x1C40             ADDS     R0,R0,#+1
   \       0x3E   0x6120             STR      R0,[R4, #+16]
    669                              OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
   \       0x40   0x....'....        BL       OSIntCtxSw
    670                          }
    671                      }
    672                  }
    673                  OS_EXIT_CRITICAL();
   \                     ??OSIntExit_2: (+1)
   \       0x44   0x4628             MOV      R0,R5
   \       0x46   0x....             B.N      ?Subroutine0
    674              }
    675          }
   \                     ??OSIntExit_0: (+1)
   \       0x48   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0x....'....        LDR.W    R4,??DataTable20
   \        0x4   0x79E0             LDRB     R0,[R4, #+7]
   \        0x6   0x2801             CMP      R0,#+1
   \        0x8   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \        0x4   0x....'....        B.W      OS_CPU_SR_Restore
    676          /*$PAGE*/
    677          /*
    678          *********************************************************************************************************
    679          *                                          PREVENT SCHEDULING
    680          *
    681          * Description: This function is used to prevent rescheduling to take place.  This allows your application
    682          *              to prevent context switches until you are ready to permit context switching.
    683          *
    684          * Arguments  : none
    685          *
    686          * Returns    : none
    687          *
    688          * Notes      : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every
    689          *                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
    690          *********************************************************************************************************
    691          */
    692          
    693          #if OS_SCHED_LOCK_EN > 0

   \                                 In section .text, align 2, keep-with-next
    694          void  OSSchedLock (void)
    695          {
   \                     OSSchedLock: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    696          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    697              OS_CPU_SR  cpu_sr = 0;
    698          #endif
    699          
    700          
    701          
    702              if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
   \        0x2   0x....'....        BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_7: (+1)
   \        0x6   0xD109             BNE.N    ??OSSchedLock_0
    703                  OS_ENTER_CRITICAL();
   \        0x8   0x....'....        BL       OS_CPU_SR_Save
    704                  if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
   \        0xC   0x78A1             LDRB     R1,[R4, #+2]
   \        0xE   0xB921             CBNZ.N   R1,??OSSchedLock_1
    705                      if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
   \       0x10   0x78E1             LDRB     R1,[R4, #+3]
   \       0x12   0x29FF             CMP      R1,#+255
   \       0x14   0xBF1C             ITT      NE 
   \       0x16   0x1C49             ADDNE    R1,R1,#+1
   \       0x18   0x70E1             STRBNE   R1,[R4, #+3]
    706                          OSLockNesting++;                 /* Increment lock nesting level                       */
    707                      }
    708                  }
    709                  OS_EXIT_CRITICAL();
   \                     ??OSSchedLock_1: (+1)
   \       0x1A   0x....             B.N      ?Subroutine1
    710              }
    711          }
   \                     ??OSSchedLock_0: (+1)
   \       0x1C   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0xE8BD 0x4010      POP      {R4,LR}
   \        0x4   0x....'....        B.W      OS_CPU_SR_Restore
    712          #endif
    713          
    714          /*$PAGE*/
    715          /*
    716          *********************************************************************************************************
    717          *                                          ENABLE SCHEDULING
    718          *
    719          * Description: This function is used to re-allow rescheduling.
    720          *
    721          * Arguments  : none
    722          *
    723          * Returns    : none
    724          *
    725          * Notes      : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every
    726          *                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
    727          *********************************************************************************************************
    728          */
    729          
    730          #if OS_SCHED_LOCK_EN > 0

   \                                 In section .text, align 2, keep-with-next
    731          void  OSSchedUnlock (void)
    732          {
   \                     OSSchedUnlock: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    733          #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    734              OS_CPU_SR  cpu_sr = 0;
    735          #endif
    736          
    737          
    738          
    739              if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
   \        0x2   0x....'....        BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_8: (+1)
   \        0x6   0xD111             BNE.N    ??OSSchedUnlock_0
    740                  OS_ENTER_CRITICAL();
   \        0x8   0x....'....        BL       OS_CPU_SR_Save
    741                  if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
   \        0xC   0x78E1             LDRB     R1,[R4, #+3]
   \        0xE   0xB161             CBZ.N    R1,??OSSchedUnlock_1
    742                      OSLockNesting--;                               /* Decrement lock nesting level             */
   \       0x10   0x1E49             SUBS     R1,R1,#+1
   \       0x12   0x70E1             STRB     R1,[R4, #+3]
    743                      if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
   \       0x14   0xB2C9             UXTB     R1,R1
   \       0x16   0x2900             CMP      R1,#+0
   \       0x18   0xBF04             ITT      EQ 
   \       0x1A   0x78A1             LDRBEQ   R1,[R4, #+2]
   \       0x1C   0x2900             CMPEQ    R1,#+0
    744                          if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
   \       0x1E   0xD104             BNE.N    ??OSSchedUnlock_1
    745                              OS_EXIT_CRITICAL();
   \       0x20   0x....'....        BL       OS_CPU_SR_Restore
    746                              OS_Sched();                            /* See if a HPT is ready                    */
   \       0x24   0xE8BD 0x4010      POP      {R4,LR}
   \       0x28   0x....             B.N      OS_Sched
    747                          } else {
    748                              OS_EXIT_CRITICAL();
    749                          }
    750                      } else {
    751                          OS_EXIT_CRITICAL();
    752                      }
    753                  } else {
    754                      OS_EXIT_CRITICAL();
   \                     ??OSSchedUnlock_1: (+1)
   \       0x2A   0x....             B.N      ?Subroutine1
    755                  }
    756              }
    757          }
   \                     ??OSSchedUnlock_0: (+1)
   \       0x2C   0xBD10             POP      {R4,PC}          ;; return
    758          #endif
    759          
    760          /*$PAGE*/
    761          /*
    762          *********************************************************************************************************
    763          *                                          START MULTITASKING
    764          *
    765          * Description: This function is used to start the multitasking process which lets uC/OS-II manages the
    766          *              task that you have created.  Before you can call OSStart(), you MUST have called OSInit()
    767          *              and you MUST have created at least one task.
    768          *
    769          * Arguments  : none
    770          *
    771          * Returns    : none
    772          *
    773          * Note       : OSStartHighRdy() MUST:
    774          *                 a) Call OSTaskSwHook() then,
    775          *                 b) Set OSRunning to OS_TRUE.
    776          *                 c) Load the context of the task pointed to by OSTCBHighRdy.
    777          *                 d_ Execute the task.
    778          *********************************************************************************************************
    779          */
    780          

   \                                 In section .text, align 2, keep-with-next
    781          void  OSStart (void)
    782          {
   \                     OSStart: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    783              if (OSRunning == OS_FALSE) {
   \        0x2   0x....'....        LDR.W    R4,??DataTable20
   \        0x6   0x79E0             LDRB     R0,[R4, #+7]
   \        0x8   0xB968             CBNZ.N   R0,??OSStart_0
    784                  OS_SchedNew();                               /* Find highest priority's task priority number   */
   \        0xA   0x....'....        BL       OS_SchedNew
    785                  OSPrioCur     = OSPrioHighRdy;
   \        0xE   0x7960             LDRB     R0,[R4, #+5]
    786                  OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
   \       0x10   0x....'....        LDR.W    R1,??DataTable20_1
   \       0x14   0x7120             STRB     R0,[R4, #+4]
   \       0x16   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \       0x1A   0x62E0             STR      R0,[R4, #+44]
    787                  OSTCBCur      = OSTCBHighRdy;
   \       0x1C   0x6260             STR      R0,[R4, #+36]
    788                  OSStartHighRdy();                            /* Execute target specific code to start task     */
   \       0x1E   0xE8BD 0x4010      POP      {R4,LR}
   \       0x22   0x....'....        B.W      OSStartHighRdy
    789              }
    790          }
   \                     ??OSStart_0: (+1)
   \       0x26   0xBD10             POP      {R4,PC}          ;; return
    791          /*$PAGE*/
    792          /*
    793          *********************************************************************************************************
    794          *                                        STATISTICS INITIALIZATION
    795          *
    796          * Description: This function is called by your application to establish CPU usage by first determining
    797          *              how high a 32-bit counter would count to in 1 second if no other tasks were to execute
    798          *              during that time.  CPU usage is then determined by a low priority task which keeps track
    799          *              of this 32-bit counter every second but this time, with other tasks running.  CPU usage is
    800          *              determined by:
    801          *
    802          *                                             OSIdleCtr
    803          *                 CPU Usage (%) = 100 * (1 - ------------)
    804          *                                            OSIdleCtrMax
    805          *
    806          * Arguments  : none
    807          *
    808          * Returns    : none
    809          *********************************************************************************************************
    810          */
    811          
    812          #if OS_TASK_STAT_EN > 0

   \                                 In section .text, align 2, keep-with-next
    813          void  OSStatInit (void)
    814          {
   \                     OSStatInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    815          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    816              OS_CPU_SR  cpu_sr = 0;
    817          #endif
    818          
    819          
    820          
    821              OSTimeDly(2);                                /* Synchronize with clock tick                        */
   \        0x2   0x2002             MOVS     R0,#+2
   \        0x4   0x....'....        BL       OSTimeDly
    822              OS_ENTER_CRITICAL();
   \        0x8   0x....'....        BL       OS_CPU_SR_Save
    823              OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
   \        0xC   0x....'....        LDR.W    R4,??DataTable20
   \       0x10   0x2100             MOVS     R1,#+0
   \       0x12   0x6221             STR      R1,[R4, #+32]
    824              OS_EXIT_CRITICAL();
   \       0x14   0x....'....        BL       OS_CPU_SR_Restore
    825              OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
   \       0x18   0x2064             MOVS     R0,#+100
   \       0x1A   0x....'....        BL       OSTimeDly
    826              OS_ENTER_CRITICAL();
   \       0x1E   0x....'....        BL       OS_CPU_SR_Save
    827              OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
   \       0x22   0x6A21             LDR      R1,[R4, #+32]
   \       0x24   0x61A1             STR      R1,[R4, #+24]
    828              OSStatRdy    = OS_TRUE;
   \       0x26   0x2201             MOVS     R2,#+1
   \       0x28   0x7062             STRB     R2,[R4, #+1]
    829              OS_EXIT_CRITICAL();
   \       0x2A                      REQUIRE ?Subroutine1
   \       0x2A                      ;; // Fall through to label ?Subroutine1
    830          }
    831          #endif
    832          /*$PAGE*/
    833          /*
    834          *********************************************************************************************************
    835          *                                         PROCESS SYSTEM TICK
    836          *
    837          * Description: This function is used to signal to uC/OS-II the occurrence of a 'system tick' (also known
    838          *              as a 'clock tick').  This function should be called by the ticker ISR but, can also be
    839          *              called by a high priority task.
    840          *
    841          * Arguments  : none
    842          *
    843          * Returns    : none
    844          *********************************************************************************************************
    845          */
    846          

   \                                 In section .text, align 2, keep-with-next
    847          void  OSTimeTick (void)
    848          {
   \                     OSTimeTick: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
    849              OS_TCB    *ptcb;
    850          #if OS_TICK_STEP_EN > 0
    851              BOOLEAN    step;
    852          #endif
    853          #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
    854              OS_CPU_SR  cpu_sr = 0;
    855          #endif
    856          
    857          
    858          
    859          #if OS_TIME_TICK_HOOK_EN > 0
    860              OSTimeTickHook();                                      /* Call user definable hook                     */
   \        0x2   0x....'....        BL       OSTimeTickHook
    861          #endif
    862          #if OS_TIME_GET_SET_EN > 0
    863              OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
   \        0x6   0x....'....        BL       OS_CPU_SR_Save
    864              OSTime++;
   \        0xA   0x....'....        LDR.W    R5,??DataTable20
   \        0xE   0x6B69             LDR      R1,[R5, #+52]
   \       0x10   0x1C49             ADDS     R1,R1,#+1
   \       0x12   0x6369             STR      R1,[R5, #+52]
    865              OS_EXIT_CRITICAL();
   \       0x14   0x....'....        BL       OS_CPU_SR_Restore
    866          #endif
    867              if (OSRunning == OS_TRUE) {
   \       0x18   0x79E8             LDRB     R0,[R5, #+7]
   \       0x1A   0x2801             CMP      R0,#+1
   \       0x1C   0xD133             BNE.N    ??OSTimeTick_0
    868          #if OS_TICK_STEP_EN > 0
    869                  switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
   \       0x1E   0x7A68             LDRB     R0,[R5, #+9]
   \       0x20   0xB140             CBZ.N    R0,??OSTimeTick_1
   \       0x22   0x2802             CMP      R0,#+2
   \       0x24   0xD001             BEQ.N    ??OSTimeTick_2
   \       0x26   0xD32E             BCC.N    ??OSTimeTick_0
   \       0x28   0xE002             B.N      ??OSTimeTick_3
    870                      case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
    871                           step = OS_TRUE;
    872                           break;
    873          
    874                      case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
    875                           step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
    876                           break;
    877          
    878                      case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
    879                           step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
    880                           OSTickStepState = OS_TICK_STEP_WAIT;
   \                     ??OSTimeTick_2: (+1)
   \       0x2A   0x2101             MOVS     R1,#+1
   \       0x2C   0x7269             STRB     R1,[R5, #+9]
    881                           break;
   \       0x2E   0xE001             B.N      ??OSTimeTick_1
    882          
    883                      default:                                       /* Invalid case, correct situation              */
    884                           step            = OS_TRUE;
    885                           OSTickStepState = OS_TICK_STEP_DIS;
   \                     ??OSTimeTick_3: (+1)
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0x7268             STRB     R0,[R5, #+9]
    886                           break;
    887                  }
    888                  if (step == OS_FALSE) {                            /* Return if waiting for step command           */
    889                      return;
    890                  }
    891          #endif
    892                  ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
   \                     ??OSTimeTick_1: (+1)
   \       0x34   0x6B2E             LDR      R6,[R5, #+48]
   \       0x36   0xE021             B.N      ??OSTimeTick_4
    893                  while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
    894                      OS_ENTER_CRITICAL();
   \                     ??OSTimeTick_5: (+1)
   \       0x38   0x....'....        BL       OS_CPU_SR_Save
    895                      if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
   \       0x3C   0x8DF1             LDRH     R1,[R6, #+46]
   \       0x3E   0xB1D1             CBZ.N    R1,??OSTimeTick_6
    896                          if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
   \       0x40   0x1E49             SUBS     R1,R1,#+1
   \       0x42   0x85F1             STRH     R1,[R6, #+46]
   \       0x44   0xB289             UXTH     R1,R1
   \       0x46   0xB9B1             CBNZ.N   R1,??OSTimeTick_6
    897                                                                     /* Check for timeout                            */
    898                              if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
   \       0x48   0x7821             LDRB     R1,[R4, #+0]
   \       0x4A   0xF011 0x0F37      TST      R1,#0x37
   \       0x4E   0xBF0F             ITEEE    EQ 
   \       0x50   0x2100             MOVEQ    R1,#+0
   \       0x52   0xF001 0x01C8      ANDNE    R1,R1,#0xC8
   \       0x56   0x7021             STRBNE   R1,[R4, #+0]
   \       0x58   0x2101             MOVNE    R1,#+1
    899                                  ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
    900                                  ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
    901                              } else {
    902                                  ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
   \       0x5A   0x7061             STRB     R1,[R4, #+1]
    903                              }
    904          
    905                              if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
   \       0x5C   0x7821             LDRB     R1,[R4, #+0]
   \       0x5E   0x070A             LSLS     R2,R1,#+28
   \       0x60   0xD409             BMI.N    ??OSTimeTick_6
    906                                  OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
   \       0x62   0x79A9             LDRB     R1,[R5, #+6]
   \       0x64   0x79A2             LDRB     R2,[R4, #+6]
   \       0x66   0x4311             ORRS     R1,R2,R1
   \       0x68   0x71A9             STRB     R1,[R5, #+6]
    907                                  OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
   \       0x6A   0x7921             LDRB     R1,[R4, #+4]
   \       0x6C   0x7963             LDRB     R3,[R4, #+5]
   \       0x6E   0x4429             ADD      R1,R5,R1
   \       0x70   0x7B0A             LDRB     R2,[R1, #+12]
   \       0x72   0x431A             ORRS     R2,R3,R2
   \       0x74   0x730A             STRB     R2,[R1, #+12]
    908                              }
    909                          }
    910                      }
    911                      ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
   \                     ??OSTimeTick_6: (+1)
   \       0x76   0x6976             LDR      R6,[R6, #+20]
    912                      OS_EXIT_CRITICAL();
   \       0x78   0x....'....        BL       OS_CPU_SR_Restore
    913                  }
   \                     ??OSTimeTick_4: (+1)
   \       0x7C   0xF106 0x0430      ADD      R4,R6,#+48
   \       0x80   0x78A0             LDRB     R0,[R4, #+2]
   \       0x82   0x281F             CMP      R0,#+31
   \       0x84   0xD1D8             BNE.N    ??OSTimeTick_5
    914              }
    915          }
   \                     ??OSTimeTick_0: (+1)
   \       0x86   0xBD70             POP      {R4-R6,PC}       ;; return
    916          
    917          /*$PAGE*/
    918          /*
    919          *********************************************************************************************************
    920          *                                             GET VERSION
    921          *
    922          * Description: This function is used to return the version number of uC/OS-II.  The returned value
    923          *              corresponds to uC/OS-II's version number multiplied by 100.  In other words, version 2.00
    924          *              would be returned as 200.
    925          *
    926          * Arguments  : none
    927          *
    928          * Returns    : the version number of uC/OS-II multiplied by 100.
    929          *********************************************************************************************************
    930          */
    931          

   \                                 In section .text, align 2, keep-with-next
    932          INT16U  OSVersion (void)
    933          {
    934              return (OS_VERSION);
   \                     OSVersion: (+1)
   \        0x0   0xF44F 0x708F      MOV      R0,#+286
   \        0x4   0x4770             BX       LR               ;; return
    935          }
    936          
    937          /*$PAGE*/
    938          /*
    939          *********************************************************************************************************
    940          *                                            DUMMY FUNCTION
    941          *
    942          * Description: This function doesn't do anything.  It is called by OSTaskDel().
    943          *
    944          * Arguments  : none
    945          *
    946          * Returns    : none
    947          *********************************************************************************************************
    948          */
    949          
    950          #if OS_TASK_DEL_EN > 0

   \                                 In section .text, align 2, keep-with-next
    951          void  OS_Dummy (void)
    952          {
    953          }
   \                     OS_Dummy: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    954          #endif
    955          
    956          /*$PAGE*/
    957          /*
    958          *********************************************************************************************************
    959          *                             MAKE TASK READY TO RUN BASED ON EVENT OCCURING
    960          *
    961          * Description: This function is called by other uC/OS-II services and is used to ready a task that was
    962          *              waiting for an event to occur.
    963          *
    964          * Arguments  : pevent      is a pointer to the event control block corresponding to the event.
    965          *
    966          *              pmsg        is a pointer to a message.  This pointer is used by message oriented services
    967          *                          such as MAILBOXEs and QUEUEs.  The pointer is not used when called by other
    968          *                          service functions.
    969          *
    970          *              msk         is a mask that is used to clear the status byte of the TCB.  For example,
    971          *                          OSSemPost() will pass OS_STAT_SEM, OSMboxPost() will pass OS_STAT_MBOX etc.
    972          *
    973          *              pend_stat   is used to indicate the readied task's pending status:
    974          *
    975          *                          OS_STAT_PEND_OK      Task ready due to a post (or delete), not a timeout or
    976          *                                               an abort.
    977          *                          OS_STAT_PEND_ABORT   Task ready due to an abort.
    978          *
    979          * Returns    : none
    980          *
    981          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
    982          *********************************************************************************************************
    983          */
    984          #if (OS_EVENT_EN)

   \                                 In section .text, align 2, keep-with-next
    985          INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
    986          {
   \                     OS_EventTaskRdy: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
    987              OS_TCB  *ptcb;
    988              INT8U    y;
    989              INT8U    x;
    990              INT8U    prio;
    991          #if OS_LOWEST_PRIO > 63
    992              INT16U  *ptbl;
    993          #endif
    994          
    995          
    996          #if OS_LOWEST_PRIO <= 63
    997              y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
   \        0x4   0x....'....        LDR.W    R0,??DataTable20_2
   \        0x8   0x7AA5             LDRB     R5,[R4, #+10]
   \        0xA   0x5D47             LDRB     R7,[R0, R5]
    998              x    = OSUnMapTbl[pevent->OSEventTbl[y]];
    999              prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
   \        0xC   0x19E6             ADDS     R6,R4,R7
   \        0xE   0x7AF5             LDRB     R5,[R6, #+11]
   \       0x10   0x5D45             LDRB     R5,[R0, R5]
   1000          #else
   1001              if ((pevent->OSEventGrp & 0xFF) != 0) {             /* Find HPT waiting for message                */
   1002                  y = OSUnMapTbl[ pevent->OSEventGrp & 0xFF];
   1003              } else {
   1004                  y = OSUnMapTbl[(pevent->OSEventGrp >> 8) & 0xFF] + 8;
   1005              }
   1006              ptbl = &pevent->OSEventTbl[y];
   1007              if ((*ptbl & 0xFF) != 0) {
   1008                  x = OSUnMapTbl[*ptbl & 0xFF];
   1009              } else {
   1010                  x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
   1011              }
   1012              prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
   1013          #endif
   1014          
   1015              ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
   \       0x12   0x....'....        LDR.W    R0,??DataTable20_1
   \       0x16   0xEB05 0x05C7      ADD      R5,R5,R7, LSL #+3
   \       0x1A   0xB2EE             UXTB     R6,R5
   \       0x1C   0xF850 0x6026      LDR      R6,[R0, R6, LSL #+2]
   1016              ptcb->OSTCBDly        =  0;                         /* Prevent OSTimeTick() from readying task     */
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x85F0             STRH     R0,[R6, #+46]
   1017          #if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
   1018              ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
   \       0x24   0x6271             STR      R1,[R6, #+36]
   1019          #else
   1020              pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
   1021          #endif
   1022              ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
   \       0x26   0xF106 0x0130      ADD      R1,R6,#+48
   \       0x2A   0x7808             LDRB     R0,[R1, #+0]
   1023              ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
   \       0x2C   0x704B             STRB     R3,[R1, #+1]
   \       0x2E   0xEA20 0x0202      BIC      R2,R0,R2
   \       0x32   0x700A             STRB     R2,[R1, #+0]
   1024                                                                  /* See if task is ready (could be susp'd)      */
   1025              if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
   \       0x34   0x780A             LDRB     R2,[R1, #+0]
   \       0x36   0x0710             LSLS     R0,R2,#+28
   \       0x38   0xD40A             BMI.N    ??OS_EventTaskRdy_0
   1026                  OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
   \       0x3A   0x....             LDR.N    R2,??DataTable20
   \       0x3C   0x7988             LDRB     R0,[R1, #+6]
   \       0x3E   0x7993             LDRB     R3,[R2, #+6]
   \       0x40   0x4303             ORRS     R3,R0,R3
   \       0x42   0x7193             STRB     R3,[R2, #+6]
   1027                  OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
   \       0x44   0x19D0             ADDS     R0,R2,R7
   \       0x46   0x7B03             LDRB     R3,[R0, #+12]
   \       0x48   0x7948             LDRB     R0,[R1, #+5]
   \       0x4A   0x4303             ORRS     R3,R0,R3
   \       0x4C   0x19D0             ADDS     R0,R2,R7
   \       0x4E   0x7303             STRB     R3,[R0, #+12]
   1028              }
   1029          
   1030              OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
   \                     ??OS_EventTaskRdy_0: (+1)
   \       0x50   0x4621             MOV      R1,R4
   \       0x52   0x4630             MOV      R0,R6
   \       0x54   0x....'....        BL       OS_EventTaskRemove
   1031          #if (OS_EVENT_MULTI_EN > 0)
   1032              if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
   \       0x58   0x6A31             LDR      R1,[R6, #+32]
   \       0x5A   0xB119             CBZ.N    R1,??OS_EventTaskRdy_1
   1033                  OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
   \       0x5C   0x4630             MOV      R0,R6
   \       0x5E   0x....'....        BL       OS_EventTaskRemoveMulti
   1034                  ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
   \       0x62   0x61F4             STR      R4,[R6, #+28]
   1035              }
   1036          #endif
   1037          
   1038              return (prio);
   \                     ??OS_EventTaskRdy_1: (+1)
   \       0x64   0xB2E8             UXTB     R0,R5
   \       0x66   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1039          }
   1040          #endif
   1041          /*$PAGE*/
   1042          /*
   1043          *********************************************************************************************************
   1044          *                                   MAKE TASK WAIT FOR EVENT TO OCCUR
   1045          *
   1046          * Description: This function is called by other uC/OS-II services to suspend a task because an event has
   1047          *              not occurred.
   1048          *
   1049          * Arguments  : pevent   is a pointer to the event control block for which the task will be waiting for.
   1050          *
   1051          * Returns    : none
   1052          *
   1053          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
   1054          *********************************************************************************************************
   1055          */
   1056          #if (OS_EVENT_EN)

   \                                 In section .text, align 2, keep-with-next
   1057          void  OS_EventTaskWait (OS_EVENT *pevent)
   1058          {
   \                     OS_EventTaskWait: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   1059              INT8U  y;
   1060          
   1061          
   1062              OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
   \        0x2   0x....             LDR.N    R2,??DataTable20
   \        0x4   0x6A51             LDR      R1,[R2, #+36]
   \        0x6   0xF841 0x0F1C      STR      R0,[R1, #+28]!
   1063          
   1064              pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
   \        0xA   0x7E0B             LDRB     R3,[R1, #+24]
   \        0xC   0x7E49             LDRB     R1,[R1, #+25]
   \        0xE   0x4403             ADD      R3,R0,R3
   \       0x10   0x7ADC             LDRB     R4,[R3, #+11]
   \       0x12   0x430C             ORRS     R4,R1,R4
   \       0x14   0x72DC             STRB     R4,[R3, #+11]
   1065              pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
   \       0x16   0x6A54             LDR      R4,[R2, #+36]
   \       0x18   0x7A83             LDRB     R3,[R0, #+10]
   \       0x1A   0xF894 0x1036      LDRB     R1,[R4, #+54]
   \       0x1E   0x430B             ORRS     R3,R1,R3
   \       0x20   0x7283             STRB     R3,[R0, #+10]
   1066          
   1067              y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
   \       0x22   0x....'....        BL       ?Subroutine5
   1068              OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
   1069              if (OSRdyTbl[y] == 0) {
   1070                  OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
   1071              }
   1072          }
   \                     ??CrossCallReturnLabel_9: (+1)
   \       0x26   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \        0x0   0x6A50             LDR      R0,[R2, #+36]
   \        0x2   0xF810 0x1F34      LDRB     R1,[R0, #+52]!
   \        0x6   0x1853             ADDS     R3,R2,R1
   \        0x8   0x4411             ADD      R1,R2,R1
   \        0xA   0x7B1C             LDRB     R4,[R3, #+12]
   \        0xC   0x7843             LDRB     R3,[R0, #+1]
   \        0xE   0xEA34 0x0303      BICS     R3,R4,R3
   \       0x12   0x730B             STRB     R3,[R1, #+12]
   \       0x14   0xD103             BNE.N    ??Subroutine5_0
   \       0x16   0x7991             LDRB     R1,[R2, #+6]
   \       0x18   0x7880             LDRB     R0,[R0, #+2]
   \       0x1A   0x4381             BICS     R1,R1,R0
   \       0x1C   0x7191             STRB     R1,[R2, #+6]
   \                     ??Subroutine5_0: (+1)
   \       0x1E   0x4770             BX       LR
   1073          #endif
   1074          /*$PAGE*/
   1075          /*
   1076          *********************************************************************************************************
   1077          *                          MAKE TASK WAIT FOR ANY OF MULTIPLE EVENTS TO OCCUR
   1078          *
   1079          * Description: This function is called by other uC/OS-II services to suspend a task because any one of
   1080          *              multiple events has not occurred.
   1081          *
   1082          * Arguments  : pevents_wait     is a pointer to an array of event control blocks, NULL-terminated, for 
   1083          *                               which the task will be waiting for.
   1084          *
   1085          * Returns    : none.
   1086          *
   1087          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
   1088          *********************************************************************************************************
   1089          */
   1090          #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))

   \                                 In section .text, align 2, keep-with-next
   1091          void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
   1092          {
   \                     OS_EventTaskWaitMulti: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   1093              OS_EVENT **pevents;
   1094              OS_EVENT  *pevent;
   1095              INT8U      y;
   1096          
   1097          
   1098              OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
   \        0x2   0x....             LDR.N    R2,??DataTable20
   \        0x4   0x4601             MOV      R1,R0
   \        0x6   0x6A50             LDR      R0,[R2, #+36]
   \        0x8   0x2300             MOVS     R3,#+0
   \        0xA   0x61C3             STR      R3,[R0, #+28]
   1099              OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
   \        0xC   0x6201             STR      R1,[R0, #+32]
   1100          
   1101              pevents =  pevents_wait;
   1102              pevent  = *pevents;
   \        0xE   0x6808             LDR      R0,[R1, #+0]
   \       0x10   0xE00F             B.N      ??OS_EventTaskWaitMulti_0
   1103              while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
   1104                  pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
   \                     ??OS_EventTaskWaitMulti_1: (+1)
   \       0x12   0x6A53             LDR      R3,[R2, #+36]
   \       0x14   0xF813 0x4F34      LDRB     R4,[R3, #+52]!
   \       0x18   0x785B             LDRB     R3,[R3, #+1]
   \       0x1A   0x4404             ADD      R4,R0,R4
   \       0x1C   0x7AE5             LDRB     R5,[R4, #+11]
   \       0x1E   0x431D             ORRS     R5,R3,R5
   \       0x20   0x72E5             STRB     R5,[R4, #+11]
   1105                  pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
   \       0x22   0x6A53             LDR      R3,[R2, #+36]
   \       0x24   0x7A84             LDRB     R4,[R0, #+10]
   \       0x26   0xF893 0x5036      LDRB     R5,[R3, #+54]
   \       0x2A   0x432C             ORRS     R4,R5,R4
   \       0x2C   0x7284             STRB     R4,[R0, #+10]
   1106                  pevents++;
   1107                  pevent = *pevents;
   \       0x2E   0xF851 0x0F04      LDR      R0,[R1, #+4]!
   1108              }
   \                     ??OS_EventTaskWaitMulti_0: (+1)
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD1ED             BNE.N    ??OS_EventTaskWaitMulti_1
   1109          
   1110              y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
   \       0x36   0x....'....        BL       ?Subroutine5
   1111              OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
   1112              if (OSRdyTbl[y] == 0) {
   1113                  OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
   1114              }
   1115          }
   \                     ??CrossCallReturnLabel_10: (+1)
   \       0x3A   0xBD30             POP      {R4,R5,PC}       ;; return
   1116          #endif
   1117          /*$PAGE*/
   1118          /*
   1119          *********************************************************************************************************
   1120          *                                   REMOVE TASK FROM EVENT WAIT LIST
   1121          *
   1122          * Description: Remove a task from an event's wait list.
   1123          *
   1124          * Arguments  : ptcb     is a pointer to the task to remove.
   1125          *
   1126          *              pevent   is a pointer to the event control block.
   1127          *
   1128          * Returns    : none
   1129          *
   1130          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
   1131          *********************************************************************************************************
   1132          */
   1133          #if (OS_EVENT_EN)

   \                                 In section .text, align 2, keep-with-next
   1134          void  OS_EventTaskRemove (OS_TCB   *ptcb,
   1135                                    OS_EVENT *pevent)
   1136          {
   \                     OS_EventTaskRemove: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   1137              INT8U  y;
   1138          
   1139          
   1140              y                       =  ptcb->OSTCBY;
   \        0x2   0xF810 0x2F34      LDRB     R2,[R0, #+52]!
   1141              pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
   \        0x6   0x188B             ADDS     R3,R1,R2
   \        0x8   0x440A             ADD      R2,R1,R2
   \        0xA   0x7ADC             LDRB     R4,[R3, #+11]
   \        0xC   0x7843             LDRB     R3,[R0, #+1]
   \        0xE   0xEA34 0x0303      BICS     R3,R4,R3
   \       0x12   0x72D3             STRB     R3,[R2, #+11]
   1142              if (pevent->OSEventTbl[y] == 0) {
   \       0x14   0xD103             BNE.N    ??OS_EventTaskRemove_0
   1143                  pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
   \       0x16   0x7A8A             LDRB     R2,[R1, #+10]
   \       0x18   0x7880             LDRB     R0,[R0, #+2]
   \       0x1A   0x4382             BICS     R2,R2,R0
   \       0x1C   0x728A             STRB     R2,[R1, #+10]
   1144              }
   1145          }
   \                     ??OS_EventTaskRemove_0: (+1)
   \       0x1E   0xBD10             POP      {R4,PC}          ;; return
   1146          #endif
   1147          /*$PAGE*/
   1148          /*
   1149          *********************************************************************************************************
   1150          *                             REMOVE TASK FROM MULTIPLE EVENTS WAIT LISTS
   1151          *
   1152          * Description: Remove a task from multiple events' wait lists.
   1153          *
   1154          * Arguments  : ptcb             is a pointer to the task to remove.
   1155          *
   1156          *              pevents_multi    is a pointer to the array of event control blocks, NULL-terminated.
   1157          *
   1158          * Returns    : none
   1159          *
   1160          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
   1161          *********************************************************************************************************
   1162          */
   1163          #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))

   \                                 In section .text, align 2, keep-with-next
   1164          void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
   1165                                         OS_EVENT **pevents_multi)
   1166          {
   \                     OS_EventTaskRemoveMulti: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   1167              OS_EVENT **pevents;
   1168              OS_EVENT  *pevent;
   1169              INT8U      y;
   1170          #if (OS_LOWEST_PRIO <= 63)
   1171              INT8U      bity;
   1172              INT8U      bitx;
   1173          #else
   1174              INT16U     bity;
   1175              INT16U     bitx;
   1176          #endif
   1177          
   1178          
   1179              y       =  ptcb->OSTCBY;
   \        0x2   0xF810 0x2F34      LDRB     R2,[R0, #+52]!
   1180              bity    =  ptcb->OSTCBBitY;
   \        0x6   0x7883             LDRB     R3,[R0, #+2]
   1181              bitx    =  ptcb->OSTCBBitX;
   \        0x8   0x7844             LDRB     R4,[R0, #+1]
   1182              pevents =  pevents_multi;
   1183              pevent  = *pevents;
   \        0xA   0x6808             LDR      R0,[R1, #+0]
   \        0xC   0xE00B             B.N      ??OS_EventTaskRemoveMulti_0
   1184              while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
   1185                  pevent->OSEventTbl[y]  &= ~bitx;
   \                     ??OS_EventTaskRemoveMulti_1: (+1)
   \        0xE   0x1885             ADDS     R5,R0,R2
   \       0x10   0xEB00 0x0602      ADD      R6,R0,R2
   \       0x14   0x7AED             LDRB     R5,[R5, #+11]
   \       0x16   0x43A5             BICS     R5,R5,R4
   \       0x18   0x72F5             STRB     R5,[R6, #+11]
   1186                  if (pevent->OSEventTbl[y] == 0) {
   \       0x1A   0xD102             BNE.N    ??OS_EventTaskRemoveMulti_2
   1187                      pevent->OSEventGrp &= ~bity;
   \       0x1C   0x7A85             LDRB     R5,[R0, #+10]
   \       0x1E   0x439D             BICS     R5,R5,R3
   \       0x20   0x7285             STRB     R5,[R0, #+10]
   1188                  }
   1189                  pevents++;
   1190                  pevent = *pevents;
   \                     ??OS_EventTaskRemoveMulti_2: (+1)
   \       0x22   0xF851 0x0F04      LDR      R0,[R1, #+4]!
   1191              }
   \                     ??OS_EventTaskRemoveMulti_0: (+1)
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD1F1             BNE.N    ??OS_EventTaskRemoveMulti_1
   1192          }
   \       0x2A   0xBD70             POP      {R4-R6,PC}       ;; return
   1193          #endif
   1194          /*$PAGE*/
   1195          /*
   1196          *********************************************************************************************************
   1197          *                                 INITIALIZE EVENT CONTROL BLOCK'S WAIT LIST
   1198          *
   1199          * Description: This function is called by other uC/OS-II services to initialize the event wait list.
   1200          *
   1201          * Arguments  : pevent    is a pointer to the event control block allocated to the event.
   1202          *
   1203          * Returns    : none
   1204          *
   1205          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
   1206          *********************************************************************************************************
   1207          */
   1208          #if (OS_EVENT_EN)

   \                                 In section .text, align 2, keep-with-next
   1209          void  OS_EventWaitListInit (OS_EVENT *pevent)
   1210          {
   1211          #if OS_LOWEST_PRIO <= 63
   1212              INT8U  *ptbl;
   1213          #else
   1214              INT16U *ptbl;
   1215          #endif
   1216              INT8U   i;
   1217          
   1218          
   1219              pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
   \                     OS_EventWaitListInit: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x7281             STRB     R1,[R0, #+10]
   1220              ptbl               = &pevent->OSEventTbl[0];
   1221          
   1222              for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
   1223                  *ptbl++ = 0;
   \        0x4   0x300B             ADDS     R0,R0,#+11
   \        0x6   0x2104             MOVS     R1,#+4
   \        0x8   0x....'....        B.W      __aeabi_memclr
   1224              }
   1225          }
   1226          #endif
   1227          /*$PAGE*/
   1228          /*
   1229          *********************************************************************************************************
   1230          *                                             INITIALIZATION
   1231          *                           INITIALIZE THE FREE LIST OF EVENT CONTROL BLOCKS
   1232          *
   1233          * Description: This function is called by OSInit() to initialize the free list of event control blocks.
   1234          *
   1235          * Arguments  : none
   1236          *
   1237          * Returns    : none
   1238          *********************************************************************************************************
   1239          */
   1240          
   1241          static  void  OS_InitEventList (void)
   1242          {
   1243          #if (OS_EVENT_EN) && (OS_MAX_EVENTS > 0)
   1244          #if (OS_MAX_EVENTS > 1)
   1245              INT16U     i;
   1246              OS_EVENT  *pevent1;
   1247              OS_EVENT  *pevent2;
   1248          
   1249          
   1250              OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
   1251              pevent1 = &OSEventTbl[0];
   1252              pevent2 = &OSEventTbl[1];
   1253              for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
   1254                  pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
   1255                  pevent1->OSEventPtr     = pevent2;
   1256          #if OS_EVENT_NAME_SIZE > 1
   1257                  pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
   1258                  pevent1->OSEventName[1] = OS_ASCII_NUL;
   1259          #endif
   1260                  pevent1++;
   1261                  pevent2++;
   1262              }
   1263              pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
   1264              pevent1->OSEventPtr             = (OS_EVENT *)0;
   1265          #if OS_EVENT_NAME_SIZE > 1
   1266              pevent1->OSEventName[0]         = '?';
   1267              pevent1->OSEventName[1]         = OS_ASCII_NUL;
   1268          #endif
   1269              OSEventFreeList                 = &OSEventTbl[0];
   1270          #else
   1271              OSEventFreeList                 = &OSEventTbl[0];       /* Only have ONE event control block       */
   1272              OSEventFreeList->OSEventType    = OS_EVENT_TYPE_UNUSED;
   1273              OSEventFreeList->OSEventPtr     = (OS_EVENT *)0;
   1274          #if OS_EVENT_NAME_SIZE > 1
   1275              OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
   1276              OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
   1277          #endif
   1278          #endif
   1279          #endif
   1280          }
   1281          /*$PAGE*/
   1282          /*
   1283          *********************************************************************************************************
   1284          *                                             INITIALIZATION
   1285          *                                    INITIALIZE MISCELLANEOUS VARIABLES
   1286          *
   1287          * Description: This function is called by OSInit() to initialize miscellaneous variables.
   1288          *
   1289          * Arguments  : none
   1290          *
   1291          * Returns    : none
   1292          *********************************************************************************************************
   1293          */
   1294          
   1295          static  void  OS_InitMisc (void)
   1296          {
   1297          #if OS_TIME_GET_SET_EN > 0
   1298              OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
   1299          #endif
   1300          
   1301              OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
   1302              OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
   1303          
   1304              OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
   1305          
   1306              OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
   1307          
   1308              OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
   1309              OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
   1310          
   1311          #if OS_TASK_STAT_EN > 0
   1312              OSIdleCtrRun  = 0L;
   1313              OSIdleCtrMax  = 0L;
   1314              OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
   1315          #endif
   1316          }
   1317          /*$PAGE*/
   1318          /*
   1319          *********************************************************************************************************
   1320          *                                             INITIALIZATION
   1321          *                                       INITIALIZE THE READY LIST
   1322          *
   1323          * Description: This function is called by OSInit() to initialize the Ready List.
   1324          *
   1325          * Arguments  : none
   1326          *
   1327          * Returns    : none
   1328          *********************************************************************************************************
   1329          */
   1330          
   1331          static  void  OS_InitRdyList (void)
   1332          {
   1333              INT8U    i;
   1334          #if OS_LOWEST_PRIO <= 63
   1335              INT8U   *prdytbl;
   1336          #else
   1337              INT16U  *prdytbl;
   1338          #endif
   1339          
   1340          
   1341              OSRdyGrp      = 0;                                     /* Clear the ready list                     */
   1342              prdytbl       = &OSRdyTbl[0];
   1343              for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
   1344                  *prdytbl++ = 0;
   1345              }
   1346          
   1347              OSPrioCur     = 0;
   1348              OSPrioHighRdy = 0;
   1349          
   1350              OSTCBHighRdy  = (OS_TCB *)0;
   1351              OSTCBCur      = (OS_TCB *)0;
   1352          }
   1353          
   1354          /*$PAGE*/
   1355          /*
   1356          *********************************************************************************************************
   1357          *                                             INITIALIZATION
   1358          *                                         CREATING THE IDLE TASK
   1359          *
   1360          * Description: This function creates the Idle Task.
   1361          *
   1362          * Arguments  : none
   1363          *
   1364          * Returns    : none
   1365          *********************************************************************************************************
   1366          */
   1367          
   1368          static  void  OS_InitTaskIdle (void)
   1369          {
   1370          #if OS_TASK_NAME_SIZE > 7
   1371              INT8U  err;
   1372          #endif
   1373          
   1374          
   1375          #if OS_TASK_CREATE_EXT_EN > 0
   1376              #if OS_STK_GROWTH == 1
   1377              (void)OSTaskCreateExt(OS_TaskIdle,
   1378                                    (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
   1379                                    &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1], /* Set Top-Of-Stack                     */
   1380                                    OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
   1381                                    OS_TASK_IDLE_ID,
   1382                                    &OSTaskIdleStk[0],                         /* Set Bottom-Of-Stack                  */
   1383                                    OS_TASK_IDLE_STK_SIZE,
   1384                                    (void *)0,                                 /* No TCB extension                     */
   1385                                    OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
   1386              #else
   1387              (void)OSTaskCreateExt(OS_TaskIdle,
   1388                                    (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
   1389                                    &OSTaskIdleStk[0],                         /* Set Top-Of-Stack                     */
   1390                                    OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
   1391                                    OS_TASK_IDLE_ID,
   1392                                    &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1], /* Set Bottom-Of-Stack                  */
   1393                                    OS_TASK_IDLE_STK_SIZE,
   1394                                    (void *)0,                                 /* No TCB extension                     */
   1395                                    OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
   1396              #endif
   1397          #else
   1398              #if OS_STK_GROWTH == 1
   1399              (void)OSTaskCreate(OS_TaskIdle,
   1400                                 (void *)0,
   1401                                 &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1],
   1402                                 OS_TASK_IDLE_PRIO);
   1403              #else
   1404              (void)OSTaskCreate(OS_TaskIdle,
   1405                                 (void *)0,
   1406                                 &OSTaskIdleStk[0],
   1407                                 OS_TASK_IDLE_PRIO);
   1408              #endif
   1409          #endif
   1410          
   1411          #if OS_TASK_NAME_SIZE > 14
   1412              OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
   1413          #else
   1414          #if OS_TASK_NAME_SIZE > 7
   1415              OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
   1416          #endif
   1417          #endif
   1418          }
   1419          /*$PAGE*/
   1420          /*
   1421          *********************************************************************************************************
   1422          *                                             INITIALIZATION
   1423          *                                      CREATING THE STATISTIC TASK
   1424          *
   1425          * Description: This function creates the Statistic Task.
   1426          *
   1427          * Arguments  : none
   1428          *
   1429          * Returns    : none
   1430          *********************************************************************************************************
   1431          */
   1432          
   1433          #if OS_TASK_STAT_EN > 0
   1434          static  void  OS_InitTaskStat (void)
   1435          {
   1436          #if OS_TASK_NAME_SIZE > 7
   1437              INT8U  err;
   1438          #endif
   1439          
   1440          
   1441          #if OS_TASK_CREATE_EXT_EN > 0
   1442              #if OS_STK_GROWTH == 1
   1443              (void)OSTaskCreateExt(OS_TaskStat,
   1444                                    (void *)0,                                   /* No args passed to OS_TaskStat()*/
   1445                                    &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1],   /* Set Top-Of-Stack               */
   1446                                    OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
   1447                                    OS_TASK_STAT_ID,
   1448                                    &OSTaskStatStk[0],                           /* Set Bottom-Of-Stack            */
   1449                                    OS_TASK_STAT_STK_SIZE,
   1450                                    (void *)0,                                   /* No TCB extension               */
   1451                                    OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
   1452              #else
   1453              (void)OSTaskCreateExt(OS_TaskStat,
   1454                                    (void *)0,                                   /* No args passed to OS_TaskStat()*/
   1455                                    &OSTaskStatStk[0],                           /* Set Top-Of-Stack               */
   1456                                    OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
   1457                                    OS_TASK_STAT_ID,
   1458                                    &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1],   /* Set Bottom-Of-Stack            */
   1459                                    OS_TASK_STAT_STK_SIZE,
   1460                                    (void *)0,                                   /* No TCB extension               */
   1461                                    OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
   1462              #endif
   1463          #else
   1464              #if OS_STK_GROWTH == 1
   1465              (void)OSTaskCreate(OS_TaskStat,
   1466                                 (void *)0,                                      /* No args passed to OS_TaskStat()*/
   1467                                 &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1],      /* Set Top-Of-Stack               */
   1468                                 OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
   1469              #else
   1470              (void)OSTaskCreate(OS_TaskStat,
   1471                                 (void *)0,                                      /* No args passed to OS_TaskStat()*/
   1472                                 &OSTaskStatStk[0],                              /* Set Top-Of-Stack               */
   1473                                 OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
   1474              #endif
   1475          #endif
   1476          
   1477          #if OS_TASK_NAME_SIZE > 14
   1478              OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
   1479          #else
   1480          #if OS_TASK_NAME_SIZE > 7
   1481              OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"OS-Stat", &err);
   1482          #endif
   1483          #endif
   1484          }
   1485          #endif
   1486          /*$PAGE*/
   1487          /*
   1488          *********************************************************************************************************
   1489          *                                             INITIALIZATION
   1490          *                            INITIALIZE THE FREE LIST OF TASK CONTROL BLOCKS
   1491          *
   1492          * Description: This function is called by OSInit() to initialize the free list of OS_TCBs.
   1493          *
   1494          * Arguments  : none
   1495          *
   1496          * Returns    : none
   1497          *********************************************************************************************************
   1498          */
   1499          
   1500          static  void  OS_InitTCBList (void)
   1501          {
   1502              INT8U    i;
   1503              OS_TCB  *ptcb1;
   1504              OS_TCB  *ptcb2;
   1505          
   1506          
   1507              OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
   1508              OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
   1509              ptcb1 = &OSTCBTbl[0];
   1510              ptcb2 = &OSTCBTbl[1];
   1511              for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
   1512                  ptcb1->OSTCBNext = ptcb2;
   1513          #if OS_TASK_NAME_SIZE > 1
   1514                  ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
   1515                  ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
   1516          #endif
   1517                  ptcb1++;
   1518                  ptcb2++;
   1519              }
   1520              ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
   1521          #if OS_TASK_NAME_SIZE > 1
   1522              ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
   1523              ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
   1524          #endif
   1525              OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
   1526              OSTCBFreeList           = &OSTCBTbl[0];
   1527          }
   1528          /*$PAGE*/
   1529          /*
   1530          *********************************************************************************************************
   1531          *                                        CLEAR A SECTION OF MEMORY
   1532          *
   1533          * Description: This function is called by other uC/OS-II services to clear a contiguous block of RAM.
   1534          *
   1535          * Arguments  : pdest    is the start of the RAM to clear (i.e. write 0x00 to)
   1536          *
   1537          *              size     is the number of bytes to clear.
   1538          *
   1539          * Returns    : none
   1540          *
   1541          * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
   1542          *              2) Note that we can only clear up to 64K bytes of RAM.  This is not an issue because none
   1543          *                 of the uses of this function gets close to this limit.
   1544          *              3) The clear is done one byte at a time since this will work on any processor irrespective
   1545          *                 of the alignment of the destination.
   1546          *********************************************************************************************************
   1547          */
   1548          

   \                                 In section .text, align 2, keep-with-next
   1549          void  OS_MemClr (INT8U *pdest, INT16U size)
   1550          {
   1551              while (size > 0) {
   \                     OS_MemClr: (+1)
   \        0x0   0x000A             MOVS     R2,R1
   \        0x2   0xBF18             IT       NE 
   1552                  *pdest++ = (INT8U)0;
   \        0x4   0x....'....        BNE.W    __aeabi_memclr
   1553                  size--;
   1554              }
   1555          }
   \        0x8   0x4770             BX       LR               ;; return
   1556          /*$PAGE*/
   1557          /*
   1558          *********************************************************************************************************
   1559          *                                        COPY A BLOCK OF MEMORY
   1560          *
   1561          * Description: This function is called by other uC/OS-II services to copy a block of memory from one
   1562          *              location to another.
   1563          *
   1564          * Arguments  : pdest    is a pointer to the 'destination' memory block
   1565          *
   1566          *              psrc     is a pointer to the 'source'      memory block
   1567          *
   1568          *              size     is the number of bytes to copy.
   1569          *
   1570          * Returns    : none
   1571          *
   1572          * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.  There is
   1573          *                 no provision to handle overlapping memory copy.  However, that's not a problem since this
   1574          *                 is not a situation that will happen.
   1575          *              2) Note that we can only copy up to 64K bytes of RAM
   1576          *              3) The copy is done one byte at a time since this will work on any processor irrespective
   1577          *                 of the alignment of the source and destination.
   1578          *********************************************************************************************************
   1579          */
   1580          

   \                                 In section .text, align 2, keep-with-next
   1581          void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
   1582          {
   \                     OS_MemCopy: (+1)
   \        0x0   0xE004             B.N      ??OS_MemCopy_0
   1583              while (size > 0) {
   1584                  *pdest++ = *psrc++;
   \                     ??OS_MemCopy_1: (+1)
   \        0x2   0xF811 0x3B01      LDRB     R3,[R1], #+1
   \        0x6   0xF800 0x3B01      STRB     R3,[R0], #+1
   1585                  size--;
   \        0xA   0x1E52             SUBS     R2,R2,#+1
   1586              }
   \                     ??OS_MemCopy_0: (+1)
   \        0xC   0xB293             UXTH     R3,R2
   \        0xE   0x2B00             CMP      R3,#+0
   \       0x10   0xD1F7             BNE.N    ??OS_MemCopy_1
   1587          }
   \       0x12   0x4770             BX       LR               ;; return
   1588          /*$PAGE*/
   1589          /*
   1590          *********************************************************************************************************
   1591          *                                              SCHEDULER
   1592          *
   1593          * Description: This function is called by other uC/OS-II services to determine whether a new, high
   1594          *              priority task has been made ready to run.  This function is invoked by TASK level code
   1595          *              and is not used to reschedule tasks from ISRs (see OSIntExit() for ISR rescheduling).
   1596          *
   1597          * Arguments  : none
   1598          *
   1599          * Returns    : none
   1600          *
   1601          * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
   1602          *              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
   1603          *********************************************************************************************************
   1604          */
   1605          

   \                                 In section .text, align 2, keep-with-next
   1606          void  OS_Sched (void)
   1607          {
   \                     OS_Sched: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   1608          #if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
   1609              OS_CPU_SR  cpu_sr = 0;
   1610          #endif
   1611          
   1612          
   1613          
   1614              OS_ENTER_CRITICAL();
   \        0x2   0x....'....        BL       OS_CPU_SR_Save
   1615              if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
   1616                  if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
   \        0x6   0x....             LDR.N    R5,??DataTable20
   \        0x8   0x78A9             LDRB     R1,[R5, #+2]
   \        0xA   0x4604             MOV      R4,R0
   \        0xC   0x78E8             LDRB     R0,[R5, #+3]
   \        0xE   0x4301             ORRS     R1,R0,R1
   \       0x10   0xD111             BNE.N    ??OS_Sched_0
   1617                      OS_SchedNew();
   \       0x12   0x....'....        BL       OS_SchedNew
   1618                      if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
   \       0x16   0x7968             LDRB     R0,[R5, #+5]
   \       0x18   0x7929             LDRB     R1,[R5, #+4]
   \       0x1A   0x4288             CMP      R0,R1
   \       0x1C   0xD00B             BEQ.N    ??OS_Sched_0
   1619                          OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
   \       0x1E   0x....             LDR.N    R2,??DataTable20_1
   \       0x20   0xF852 0x0020      LDR      R0,[R2, R0, LSL #+2]
   \       0x24   0x62E8             STR      R0,[R5, #+44]
   1620          #if OS_TASK_PROFILE_EN > 0
   1621                          OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
   \       0x26   0x6B81             LDR      R1,[R0, #+56]
   \       0x28   0x1C49             ADDS     R1,R1,#+1
   \       0x2A   0x6381             STR      R1,[R0, #+56]
   1622          #endif
   1623                          OSCtxSwCtr++;                          /* Increment context switch counter             */
   \       0x2C   0x6928             LDR      R0,[R5, #+16]
   \       0x2E   0x1C40             ADDS     R0,R0,#+1
   \       0x30   0x6128             STR      R0,[R5, #+16]
   1624                          OS_TASK_SW();                          /* Perform a context switch                     */
   \       0x32   0x....'....        BL       OSCtxSw
   1625                      }
   1626                  }
   1627              }
   1628              OS_EXIT_CRITICAL();
   \                     ??OS_Sched_0: (+1)
   \       0x36   0x4620             MOV      R0,R4
   \       0x38                      REQUIRE ?Subroutine0
   \       0x38                      ;; // Fall through to label ?Subroutine0
   1629          }
   1630          
   1631          
   1632          /*
   1633          *********************************************************************************************************
   1634          *                              FIND HIGHEST PRIORITY TASK READY TO RUN
   1635          *
   1636          * Description: This function is called by other uC/OS-II services to determine the highest priority task
   1637          *              that is ready to run.  The global variable 'OSPrioHighRdy' is changed accordingly.
   1638          *
   1639          * Arguments  : none
   1640          *
   1641          * Returns    : none
   1642          *
   1643          * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
   1644          *              2) Interrupts are assumed to be disabled when this function is called.
   1645          *********************************************************************************************************
   1646          */
   1647          

   \                                 In section .text, align 2, keep-with-next
   1648          static  void  OS_SchedNew (void)
   1649          {
   \                     OS_SchedNew: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   1650          #if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
   1651              INT8U   y;
   1652          
   1653          
   1654              y             = OSUnMapTbl[OSRdyGrp];
   \        0x2   0x....             LDR.N    R0,??DataTable20
   \        0x4   0x....             LDR.N    R1,??DataTable20_2
   \        0x6   0x7982             LDRB     R2,[R0, #+6]
   \        0x8   0x5C8A             LDRB     R2,[R1, R2]
   1655              OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
   \        0xA   0x1883             ADDS     R3,R0,R2
   \        0xC   0x7B1C             LDRB     R4,[R3, #+12]
   \        0xE   0x5D09             LDRB     R1,[R1, R4]
   \       0x10   0xEB01 0x01C2      ADD      R1,R1,R2, LSL #+3
   \       0x14   0x7141             STRB     R1,[R0, #+5]
   1656          #else                                            /* We support up to 256 tasks                         */
   1657              INT8U   y;
   1658              INT16U *ptbl;
   1659          
   1660          
   1661              if ((OSRdyGrp & 0xFF) != 0) {
   1662                  y = OSUnMapTbl[OSRdyGrp & 0xFF];
   1663              } else {
   1664                  y = OSUnMapTbl[(OSRdyGrp >> 8) & 0xFF] + 8;
   1665              }
   1666              ptbl = &OSRdyTbl[y];
   1667              if ((*ptbl & 0xFF) != 0) {
   1668                  OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl & 0xFF)]);
   1669              } else {
   1670                  OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8);
   1671              }
   1672          #endif
   1673          }
   \       0x16   0xBD10             POP      {R4,PC}          ;; return
   1674          
   1675          /*$PAGE*/
   1676          /*
   1677          *********************************************************************************************************
   1678          *                                        COPY AN ASCII STRING
   1679          *
   1680          * Description: This function is called by other uC/OS-II services to copy an ASCII string from a 'source'
   1681          *              string to a 'destination' string.
   1682          *
   1683          * Arguments  : pdest    is a pointer to the string that will be receiving the copy.  Note that there MUST
   1684          *                       be sufficient space in the destination storage area to receive this string.
   1685          *
   1686          *              psrc     is a pointer to the source string.  The source string MUST NOT be greater than
   1687          *                       254 characters.
   1688          *
   1689          * Returns    : The size of the string (excluding the NUL terminating character)
   1690          *
   1691          * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
   1692          *********************************************************************************************************
   1693          */
   1694          
   1695          #if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)

   \                                 In section .text, align 2, keep-with-next
   1696          INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
   1697          {
   \                     OS_StrCopy: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4603             MOV      R3,R0
   1698              INT8U  len;
   1699          
   1700          
   1701              len = 0;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0xE004             B.N      ??OS_StrCopy_0
   1702              while (*psrc != OS_ASCII_NUL) {
   1703                  *pdest++ = *psrc++;
   \                     ??OS_StrCopy_1: (+1)
   \        0x8   0xF811 0x4B01      LDRB     R4,[R1], #+1
   \        0xC   0xF803 0x4B01      STRB     R4,[R3], #+1
   1704                  len++;
   \       0x10   0x1C40             ADDS     R0,R0,#+1
   1705              }
   \                     ??OS_StrCopy_0: (+1)
   \       0x12   0x780A             LDRB     R2,[R1, #+0]
   \       0x14   0x2A00             CMP      R2,#+0
   \       0x16   0xD1F7             BNE.N    ??OS_StrCopy_1
   1706              *pdest = OS_ASCII_NUL;
   \       0x18   0x2100             MOVS     R1,#+0
   \       0x1A   0x7019             STRB     R1,[R3, #+0]
   1707              return (len);
   \       0x1C   0xB2C0             UXTB     R0,R0
   \       0x1E   0xBD10             POP      {R4,PC}          ;; return
   1708          }
   1709          #endif
   1710          /*$PAGE*/
   1711          /*
   1712          *********************************************************************************************************
   1713          *                                DETERMINE THE LENGTH OF AN ASCII STRING
   1714          *
   1715          * Description: This function is called by other uC/OS-II services to determine the size of an ASCII string
   1716          *              (excluding the NUL character).
   1717          *
   1718          * Arguments  : psrc     is a pointer to the string for which we need to know the size.
   1719          *
   1720          * Returns    : The size of the string (excluding the NUL terminating character)
   1721          *
   1722          * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
   1723          *              2) The string to check must be less than 255 characters long.
   1724          *********************************************************************************************************
   1725          */
   1726          
   1727          #if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)

   \                                 In section .text, align 2, keep-with-next
   1728          INT8U  OS_StrLen (INT8U *psrc)
   1729          {
   \                     OS_StrLen: (+1)
   \        0x0   0x4601             MOV      R1,R0
   1730              INT8U  len;
   1731          
   1732          
   1733              len = 0;
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0xE000             B.N      ??OS_StrLen_0
   1734              while (*psrc != OS_ASCII_NUL) {
   1735                  psrc++;
   1736                  len++;
   \                     ??OS_StrLen_1: (+1)
   \        0x6   0x1C40             ADDS     R0,R0,#+1
   1737              }
   \                     ??OS_StrLen_0: (+1)
   \        0x8   0xF811 0x2B01      LDRB     R2,[R1], #+1
   \        0xC   0x2A00             CMP      R2,#+0
   \        0xE   0xD1FA             BNE.N    ??OS_StrLen_1
   1738              return (len);
   \       0x10   0xB2C0             UXTB     R0,R0
   \       0x12   0x4770             BX       LR               ;; return
   1739          }
   1740          #endif
   1741          /*$PAGE*/
   1742          /*
   1743          *********************************************************************************************************
   1744          *                                              IDLE TASK
   1745          *
   1746          * Description: This task is internal to uC/OS-II and executes whenever no other higher priority tasks
   1747          *              executes because they are ALL waiting for event(s) to occur.
   1748          *
   1749          * Arguments  : none
   1750          *
   1751          * Returns    : none
   1752          *
   1753          * Note(s)    : 1) OSTaskIdleHook() is called after the critical section to ensure that interrupts will be
   1754          *                 enabled for at least a few instructions.  On some processors (ex. Philips XA), enabling
   1755          *                 and then disabling interrupts didn't allow the processor enough time to have interrupts
   1756          *                 enabled before they were disabled again.  uC/OS-II would thus never recognize
   1757          *                 interrupts.
   1758          *              2) This hook has been added to allow you to do such things as STOP the CPU to conserve
   1759          *                 power.
   1760          *********************************************************************************************************
   1761          */
   1762          

   \                                 In section .text, align 4, keep-with-next
   1763          void  OS_TaskIdle (void *p_arg)
   1764          {
   \                     OS_TaskIdle: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   1765          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
   1766              OS_CPU_SR  cpu_sr = 0;
   1767          #endif
   1768          
   1769          
   1770          
   1771              (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
   \        0x2   0x....             LDR.N    R4,??DataTable20
   1772              for (;;) {
   1773                  OS_ENTER_CRITICAL();
   \                     ??OS_TaskIdle_0: (+1)
   \        0x4   0x....'....        BL       OS_CPU_SR_Save
   1774                  OSIdleCtr++;
   \        0x8   0x6A21             LDR      R1,[R4, #+32]
   \        0xA   0x1C49             ADDS     R1,R1,#+1
   \        0xC   0x6221             STR      R1,[R4, #+32]
   1775                  OS_EXIT_CRITICAL();
   \        0xE   0x....'....        BL       OS_CPU_SR_Restore
   1776                  OSTaskIdleHook();                        /* Call user definable HOOK                           */
   \       0x12   0x....'....        BL       OSTaskIdleHook
   \       0x16   0xE7F5             B.N      ??OS_TaskIdle_0
   1777              }
   1778          }
   1779          /*$PAGE*/
   1780          /*
   1781          *********************************************************************************************************
   1782          *                                            STATISTICS TASK
   1783          *
   1784          * Description: This task is internal to uC/OS-II and is used to compute some statistics about the
   1785          *              multitasking environment.  Specifically, OS_TaskStat() computes the CPU usage.
   1786          *              CPU usage is determined by:
   1787          *
   1788          *                                          OSIdleCtr
   1789          *                 OSCPUUsage = 100 * (1 - ------------)     (units are in %)
   1790          *                                         OSIdleCtrMax
   1791          *
   1792          * Arguments  : parg     this pointer is not used at this time.
   1793          *
   1794          * Returns    : none
   1795          *
   1796          * Notes      : 1) This task runs at a priority level higher than the idle task.  In fact, it runs at the
   1797          *                 next higher priority, OS_TASK_IDLE_PRIO-1.
   1798          *              2) You can disable this task by setting the configuration #define OS_TASK_STAT_EN to 0.
   1799          *              3) You MUST have at least a delay of 2/10 seconds to allow for the system to establish the
   1800          *                 maximum value for the idle counter.
   1801          *********************************************************************************************************
   1802          */
   1803          
   1804          #if OS_TASK_STAT_EN > 0

   \                                 In section .text, align 4, keep-with-next
   1805          void  OS_TaskStat (void *p_arg)
   1806          {
   \                     OS_TaskStat: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   1807          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
   1808              OS_CPU_SR  cpu_sr = 0;
   1809          #endif
   1810          
   1811          
   1812          
   1813              (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
   \        0x2   0x....             LDR.N    R4,??DataTable20
   \        0x4   0xE002             B.N      ??OS_TaskStat_0
   1814              while (OSStatRdy == OS_FALSE) {
   1815                  OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
   \                     ??OS_TaskStat_1: (+1)
   \        0x6   0x20C8             MOVS     R0,#+200
   \        0x8   0x....'....        BL       OSTimeDly
   1816              }
   \                     ??OS_TaskStat_0: (+1)
   \        0xC   0x7860             LDRB     R0,[R4, #+1]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD0F9             BEQ.N    ??OS_TaskStat_1
   1817              OSIdleCtrMax /= 100L;
   \       0x12   0x69A0             LDR      R0,[R4, #+24]
   \       0x14   0x2164             MOVS     R1,#+100
   \       0x16   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \       0x1A   0x61A0             STR      R0,[R4, #+24]
   1818              if (OSIdleCtrMax == 0L) {
   \       0x1C   0xB918             CBNZ.N   R0,??OS_TaskStat_2
   1819                  OSCPUUsage = 0;
   \       0x1E   0x7020             STRB     R0,[R4, #+0]
   1820                  (void)OSTaskSuspend(OS_PRIO_SELF);
   \       0x20   0x20FF             MOVS     R0,#+255
   \       0x22   0x....'....        BL       OSTaskSuspend
   1821              }
   1822              for (;;) {
   1823                  OS_ENTER_CRITICAL();
   \                     ??OS_TaskStat_2: (+1)
   \       0x26   0x....'....        BL       OS_CPU_SR_Save
   1824                  OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
   \       0x2A   0x6A21             LDR      R1,[R4, #+32]
   \       0x2C   0x61E1             STR      R1,[R4, #+28]
   1825                  OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
   \       0x2E   0x2200             MOVS     R2,#+0
   \       0x30   0x6222             STR      R2,[R4, #+32]
   1826                  OS_EXIT_CRITICAL();
   \       0x32   0x....'....        BL       OS_CPU_SR_Restore
   1827                  OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
   \       0x36   0x69E0             LDR      R0,[R4, #+28]
   \       0x38   0x69A1             LDR      R1,[R4, #+24]
   \       0x3A   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \       0x3E   0xF1C1 0x0164      RSB      R1,R1,#+100
   \       0x42   0x7021             STRB     R1,[R4, #+0]
   1828                  OSTaskStatHook();                        /* Invoke user definable hook                         */
   \       0x44   0x....'....        BL       OSTaskStatHook
   1829          #if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
   1830                  OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
   \       0x48   0x....'....        BL       OS_TaskStatStkChk
   1831          #endif
   1832                  OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
   \       0x4C   0x2064             MOVS     R0,#+100
   \       0x4E   0x....'....        BL       OSTimeDly
   \       0x52   0xE7E8             B.N      ??OS_TaskStat_2
   1833              }
   1834          }
   1835          #endif
   1836          /*$PAGE*/
   1837          /*
   1838          *********************************************************************************************************
   1839          *                                      CHECK ALL TASK STACKS
   1840          *
   1841          * Description: This function is called by OS_TaskStat() to check the stacks of each active task.
   1842          *
   1843          * Arguments  : none
   1844          *
   1845          * Returns    : none
   1846          *********************************************************************************************************
   1847          */
   1848          
   1849          #if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)

   \                                 In section .text, align 2, keep-with-next
   1850          void  OS_TaskStatStkChk (void)
   1851          {
   \                     OS_TaskStatStkChk: (+1)
   \        0x0   0xB53E             PUSH     {R1-R5,LR}
   1852              OS_TCB      *ptcb;
   1853              OS_STK_DATA  stk_data;
   1854              INT8U        err;
   1855              INT8U        prio;
   1856          
   1857          
   1858              for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
   \        0x2   0x2500             MOVS     R5,#+0
   \        0x4   0x....             LDR.N    R4,??DataTable20_1
   1859                  err = OSTaskStkChk(prio, &stk_data);
   1860                  if (err == OS_ERR_NONE) {
   \                     ??OS_TaskStatStkChk_0: (+1)
   \        0x6   0x4669             MOV      R1,SP
   \        0x8   0xB2E8             UXTB     R0,R5
   \        0xA   0x....'....        BL       OSTaskStkChk
   \        0xE   0xB968             CBNZ.N   R0,??OS_TaskStatStkChk_1
   1861                      ptcb = OSTCBPrioTbl[prio];
   \       0x10   0xB2E8             UXTB     R0,R5
   \       0x12   0xF854 0x0020      LDR      R0,[R4, R0, LSL #+2]
   1862                      if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xBF18             IT       NE 
   \       0x1A   0x2801             CMPNE    R0,#+1
   1863                          if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
   \       0x1C   0xD006             BEQ.N    ??OS_TaskStatStkChk_1
   1864          #if OS_TASK_PROFILE_EN > 0
   1865                              #if OS_STK_GROWTH == 1
   1866                              ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
   \       0x1E   0x6881             LDR      R1,[R0, #+8]
   \       0x20   0x68C2             LDR      R2,[R0, #+12]
   \       0x22   0xEB01 0x0382      ADD      R3,R1,R2, LSL #+2
   \       0x26   0x6443             STR      R3,[R0, #+68]
   1867                              #else
   1868                              ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
   1869                              #endif
   1870                              ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
   \       0x28   0x9901             LDR      R1,[SP, #+4]
   \       0x2A   0x6481             STR      R1,[R0, #+72]
   1871          #endif
   1872                          }
   1873                      }
   1874                  }
   1875              }
   \                     ??OS_TaskStatStkChk_1: (+1)
   \       0x2C   0x1C6D             ADDS     R5,R5,#+1
   \       0x2E   0xB2E8             UXTB     R0,R5
   \       0x30   0x2820             CMP      R0,#+32
   \       0x32   0xDBE8             BLT.N    ??OS_TaskStatStkChk_0
   1876          }
   \       0x34   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
   1877          #endif
   1878          /*$PAGE*/
   1879          /*
   1880          *********************************************************************************************************
   1881          *                                            INITIALIZE TCB
   1882          *
   1883          * Description: This function is internal to uC/OS-II and is used to initialize a Task Control Block when
   1884          *              a task is created (see OSTaskCreate() and OSTaskCreateExt()).
   1885          *
   1886          * Arguments  : prio          is the priority of the task being created
   1887          *
   1888          *              ptos          is a pointer to the task's top-of-stack assuming that the CPU registers
   1889          *                            have been placed on the stack.  Note that the top-of-stack corresponds to a
   1890          *                            'high' memory location is OS_STK_GROWTH is set to 1 and a 'low' memory
   1891          *                            location if OS_STK_GROWTH is set to 0.  Note that stack growth is CPU
   1892          *                            specific.
   1893          *
   1894          *              pbos          is a pointer to the bottom of stack.  A NULL pointer is passed if called by
   1895          *                            'OSTaskCreate()'.
   1896          *
   1897          *              id            is the task's ID (0..65535)
   1898          *
   1899          *              stk_size      is the size of the stack (in 'stack units').  If the stack units are INT8Us
   1900          *                            then, 'stk_size' contains the number of bytes for the stack.  If the stack
   1901          *                            units are INT32Us then, the stack contains '4 * stk_size' bytes.  The stack
   1902          *                            units are established by the #define constant OS_STK which is CPU
   1903          *                            specific.  'stk_size' is 0 if called by 'OSTaskCreate()'.
   1904          *
   1905          *              pext          is a pointer to a user supplied memory area that is used to extend the task
   1906          *                            control block.  This allows you to store the contents of floating-point
   1907          *                            registers, MMU registers or anything else you could find useful during a
   1908          *                            context switch.  You can even assign a name to each task and store this name
   1909          *                            in this TCB extension.  A NULL pointer is passed if called by OSTaskCreate().
   1910          *
   1911          *              opt           options as passed to 'OSTaskCreateExt()' or,
   1912          *                            0 if called from 'OSTaskCreate()'.
   1913          *
   1914          * Returns    : OS_ERR_NONE         if the call was successful
   1915          *              OS_ERR_TASK_NO_MORE_TCB  if there are no more free TCBs to be allocated and thus, the task cannot
   1916          *                                  be created.
   1917          *
   1918          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
   1919          *********************************************************************************************************
   1920          */
   1921          

   \                                 In section .text, align 2, keep-with-next
   1922          INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
   1923          {
   \                     OS_TCBInit: (+1)
   \        0x0   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \        0x4   0xB082             SUB      SP,SP,#+8
   \        0x6   0x460E             MOV      R6,R1
   \        0x8   0x4692             MOV      R10,R2
   \        0xA   0x469B             MOV      R11,R3
   1924              OS_TCB    *ptcb;
   1925          #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
   1926              OS_CPU_SR  cpu_sr = 0;
   1927          #endif
   1928          
   1929          
   1930          
   1931              OS_ENTER_CRITICAL();
   \        0xC   0x....'....        BL       OS_CPU_SR_Save
   1932              ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
   \       0x10   0x....             LDR.N    R7,??DataTable20
   \       0x12   0x6ABC             LDR      R4,[R7, #+40]
   1933              if (ptcb != (OS_TCB *)0) {
   \       0x14   0x2C00             CMP      R4,#+0
   \       0x16   0xD060             BEQ.N    ??OS_TCBInit_0
   \       0x18   0xF8AD 0xB000      STRH     R11,[SP, #+0]
   1934                  OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
   \       0x1C   0x6961             LDR      R1,[R4, #+20]
   \       0x1E   0x9D0E             LDR      R5,[SP, #+56]
   \       0x20   0xF8DD 0x8034      LDR      R8,[SP, #+52]
   \       0x24   0xF8DD 0x9030      LDR      R9,[SP, #+48]
   \       0x28   0xF89D 0xB008      LDRB     R11,[SP, #+8]
   \       0x2C   0x62B9             STR      R1,[R7, #+40]
   1935                  OS_EXIT_CRITICAL();
   \       0x2E   0x....'....        BL       OS_CPU_SR_Restore
   1936                  ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
   \       0x32   0x6026             STR      R6,[R4, #+0]
   1937                  ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
   1938                  ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0xF104 0x0630      ADD      R6,R4,#+48
   1939                  ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
   \       0x3A   0x2100             MOVS     R1,#+0
   \       0x3C   0xF886 0xB002      STRB     R11,[R6, #+2]
   \       0x40   0x7030             STRB     R0,[R6, #+0]
   \       0x42   0x7071             STRB     R1,[R6, #+1]
   1940                  ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */
   \       0x44   0x85E0             STRH     R0,[R4, #+46]
   1941          
   1942          #if OS_TASK_CREATE_EXT_EN > 0
   1943                  ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
   \       0x46   0xF8C4 0x8004      STR      R8,[R4, #+4]
   1944                  ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
   \       0x4A   0xF8C4 0x900C      STR      R9,[R4, #+12]
   1945                  ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
   \       0x4E   0xF8C4 0xA008      STR      R10,[R4, #+8]
   1946                  ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
   \       0x52   0x8225             STRH     R5,[R4, #+16]
   1947                  ptcb->OSTCBId            = id;                     /* Store task ID                            */
   1948          #else
   1949                  pext                     = pext;                   /* Prevent compiler warning if not used     */
   1950                  stk_size                 = stk_size;
   1951                  pbos                     = pbos;
   1952                  opt                      = opt;
   1953                  id                       = id;
   1954          #endif
   1955          
   1956          #if OS_TASK_DEL_EN > 0
   1957                  ptcb->OSTCBDelReq        = OS_ERR_NONE;
   1958          #endif
   1959          
   1960          #if OS_LOWEST_PRIO <= 63
   1961                  ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
   1962                  ptcb->OSTCBX             = (INT8U)(prio & 0x07);
   1963                  ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
   \       0x54   0x2201             MOVS     R2,#+1
   \       0x56   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \       0x5A   0x8260             STRH     R0,[R4, #+18]
   \       0x5C   0x71F1             STRB     R1,[R6, #+7]
   \       0x5E   0xEA4F 0x00DB      LSR      R0,R11,#+3
   \       0x62   0x7130             STRB     R0,[R6, #+4]
   \       0x64   0xF00B 0x0107      AND      R1,R11,#0x7
   \       0x68   0x70F1             STRB     R1,[R6, #+3]
   \       0x6A   0xFA02 0xF000      LSL      R0,R2,R0
   \       0x6E   0x71B0             STRB     R0,[R6, #+6]
   1964                  ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
   \       0x70   0xFA02 0xF101      LSL      R1,R2,R1
   \       0x74   0x7171             STRB     R1,[R6, #+5]
   1965          #else
   1966                  ptcb->OSTCBY             = (INT8U)((prio >> 4) & 0xFF); /* Pre-compute X, Y, BitX and BitY     */
   1967                  ptcb->OSTCBX             = (INT8U) (prio & 0x0F);
   1968                  ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
   1969                  ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
   1970          #endif
   1971          
   1972          #if (OS_EVENT_EN)
   1973                  ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
   \       0x76   0x2000             MOVS     R0,#+0
   \       0x78   0x61E0             STR      R0,[R4, #+28]
   1974          #if (OS_EVENT_MULTI_EN > 0)
   1975                  ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
   \       0x7A   0x6220             STR      R0,[R4, #+32]
   1976          #endif
   1977          #endif
   1978          
   1979          #if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
   1980                  ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
   \       0x7C   0x62A0             STR      R0,[R4, #+40]
   1981          #endif
   1982          
   1983          #if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
   1984                  ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
   \       0x7E   0x6260             STR      R0,[R4, #+36]
   1985          #endif
   1986          
   1987          #if OS_TASK_PROFILE_EN > 0
   1988                  ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
   \       0x80   0x60B0             STR      R0,[R6, #+8]
   1989                  ptcb->OSTCBCyclesStart = 0L;
   \       0x82   0x6130             STR      R0,[R6, #+16]
   1990                  ptcb->OSTCBCyclesTot   = 0L;
   \       0x84   0x60F0             STR      R0,[R6, #+12]
   1991                  ptcb->OSTCBStkBase     = (OS_STK *)0;
   \       0x86   0x6170             STR      R0,[R6, #+20]
   1992                  ptcb->OSTCBStkUsed     = 0L;
   \       0x88   0x61B0             STR      R0,[R6, #+24]
   1993          #endif
   1994          
   1995          #if OS_TASK_NAME_SIZE > 1
   1996                  ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
   \       0x8A   0x213F             MOVS     R1,#+63
   \       0x8C   0x7731             STRB     R1,[R6, #+28]
   1997                  ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
   \       0x8E   0x7770             STRB     R0,[R6, #+29]
   1998          #endif
   1999          
   2000                  OSTCBInitHook(ptcb);
   \       0x90   0x4620             MOV      R0,R4
   \       0x92   0x....'....        BL       OSTCBInitHook
   2001          
   2002                  OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
   \       0x96   0x4620             MOV      R0,R4
   \       0x98   0x....'....        BL       OSTaskCreateHook
   2003          
   2004                  OS_ENTER_CRITICAL();
   \       0x9C   0x....'....        BL       OS_CPU_SR_Save
   2005                  OSTCBPrioTbl[prio] = ptcb;
   \       0xA0   0x....             LDR.N    R1,??DataTable20_1
   \       0xA2   0xF841 0x402B      STR      R4,[R1, R11, LSL #+2]
   2006                  ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
   2007                  ptcb->OSTCBPrev    = (OS_TCB *)0;
   \       0xA6   0x2100             MOVS     R1,#+0
   \       0xA8   0x6B3A             LDR      R2,[R7, #+48]
   \       0xAA   0x61A1             STR      R1,[R4, #+24]
   \       0xAC   0x6162             STR      R2,[R4, #+20]
   2008                  if (OSTCBList != (OS_TCB *)0) {
   \       0xAE   0x6B39             LDR      R1,[R7, #+48]
   \       0xB0   0xB101             CBZ.N    R1,??OS_TCBInit_1
   2009                      OSTCBList->OSTCBPrev = ptcb;
   \       0xB2   0x618C             STR      R4,[R1, #+24]
   2010                  }
   2011                  OSTCBList               = ptcb;
   \                     ??OS_TCBInit_1: (+1)
   \       0xB4   0x633C             STR      R4,[R7, #+48]
   2012                  OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
   \       0xB6   0x79BA             LDRB     R2,[R7, #+6]
   \       0xB8   0x79B1             LDRB     R1,[R6, #+6]
   \       0xBA   0x430A             ORRS     R2,R1,R2
   \       0xBC   0x71BA             STRB     R2,[R7, #+6]
   2013                  OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
   \       0xBE   0xF107 0x030C      ADD      R3,R7,#+12
   \       0xC2   0x7932             LDRB     R2,[R6, #+4]
   \       0xC4   0x7971             LDRB     R1,[R6, #+5]
   \       0xC6   0x5C9C             LDRB     R4,[R3, R2]
   \       0xC8   0x430C             ORRS     R4,R1,R4
   \       0xCA   0x549C             STRB     R4,[R3, R2]
   2014                  OSTaskCtr++;                                       /* Increment the #tasks counter             */
   \       0xCC   0x7A3A             LDRB     R2,[R7, #+8]
   \       0xCE   0x1C52             ADDS     R2,R2,#+1
   \       0xD0   0x723A             STRB     R2,[R7, #+8]
   2015                  OS_EXIT_CRITICAL();
   \       0xD2   0x....'....        BL       OS_CPU_SR_Restore
   2016                  return (OS_ERR_NONE);
   \       0xD6   0x2000             MOVS     R0,#+0
   \       0xD8   0xE002             B.N      ??OS_TCBInit_2
   2017              }
   2018              OS_EXIT_CRITICAL();
   \                     ??OS_TCBInit_0: (+1)
   \       0xDA   0x....'....        BL       OS_CPU_SR_Restore
   2019              return (OS_ERR_TASK_NO_MORE_TCB);
   \       0xDE   0x2042             MOVS     R0,#+66
   \                     ??OS_TCBInit_2: (+1)
   \       0xE0   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
   2020          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x9202             STR      R2,[SP, #+8]
   \        0x4   0x9301             STR      R3,[SP, #+4]
   \        0x6   0x9000             STR      R0,[SP, #+0]
   \        0x8   0x9103             STR      R1,[SP, #+12]
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \        0x0   0x....'....        DC32     OSCPUUsage

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \        0x0   0x....'....        DC32     OSTCBPrioTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_2:
   \        0x0   0x....'....        DC32     OSUnMapTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \        0x0   0x75 0x43          DC8 "uC/OS-II Idle"
   \              0x2F 0x4F    
   \              0x53 0x2D    
   \              0x49 0x49    
   \              0x20 0x49    
   \              0x64 0x6C    
   \              0x65 0x00    
   \        0xE   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \        0x0   0x75 0x43          DC8 "uC/OS-II Stat"
   \              0x2F 0x4F    
   \              0x53 0x2D    
   \              0x49 0x49    
   \              0x20 0x53    
   \              0x74 0x61    
   \              0x74 0x00    
   \        0xE   0x00 0x00          DC8 0, 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   OSEventNameGet
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
        24   -> OS_StrCopy
      24   OSEventNameSet
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
        24   -> OS_StrCopy
        24   -> OS_StrLen
      48   OSEventPendMulti
        48   -> OS_CPU_SR_Restore
        48   -> OS_CPU_SR_Save
        48   -> OS_EventTaskRemoveMulti
        48   -> OS_EventTaskWaitMulti
        48   -> OS_Sched
      48   OSInit
        48   -> OSDebugInit
        48   -> OSInitHookBegin
        48   -> OSInitHookEnd
        48   -> OSTaskCreateExt
        48   -> OSTaskNameSet
        48   -> OS_FlagInit
        48   -> OS_MemClr
        48   -> __aeabi_memclr
       0   OSIntEnter
      16   OSIntExit
        16   -> OSIntCtxSw
         0   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
        16   -> OS_SchedNew
       8   OSSchedLock
         0   -> OS_CPU_SR_Restore
         8   -> OS_CPU_SR_Save
       8   OSSchedUnlock
         0   -> OS_CPU_SR_Restore
         8   -> OS_CPU_SR_Restore
         8   -> OS_CPU_SR_Save
         0   -> OS_Sched
       8   OSStart
         0   -> OSStartHighRdy
         8   -> OS_SchedNew
       8   OSStatInit
         8   -> OSTimeDly
         0   -> OS_CPU_SR_Restore
         8   -> OS_CPU_SR_Restore
         8   -> OS_CPU_SR_Save
      16   OSTimeTick
        16   -> OSTimeTickHook
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
       0   OSVersion
       0   OS_Dummy
      24   OS_EventTaskRdy
        24   -> OS_EventTaskRemove
        24   -> OS_EventTaskRemoveMulti
       8   OS_EventTaskRemove
      16   OS_EventTaskRemoveMulti
       8   OS_EventTaskWait
      12   OS_EventTaskWaitMulti
       0   OS_EventWaitListInit
         0   -> __aeabi_memclr
       0   OS_MemClr
         0   -> __aeabi_memclr
       0   OS_MemCopy
      16   OS_Sched
        16   -> OSCtxSw
         0   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
        16   -> OS_SchedNew
       8   OS_SchedNew
       8   OS_StrCopy
       0   OS_StrLen
      48   OS_TCBInit
        48   -> OSTCBInitHook
        48   -> OSTaskCreateHook
        48   -> OS_CPU_SR_Restore
        48   -> OS_CPU_SR_Save
       8   OS_TaskIdle
         8   -> OSTaskIdleHook
         8   -> OS_CPU_SR_Restore
         8   -> OS_CPU_SR_Save
       8   OS_TaskStat
         8   -> OSTaskStatHook
         8   -> OSTaskSuspend
         8   -> OSTimeDly
         8   -> OS_CPU_SR_Restore
         8   -> OS_CPU_SR_Save
         8   -> OS_TaskStatStkChk
      24   OS_TaskStatStkChk
        24   -> OSTaskStkChk


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_2
       8  ?Subroutine0
       8  ?Subroutine1
      14  ?Subroutine2
       6  ?Subroutine3
      10  ?Subroutine4
      32  ?Subroutine5
      12  ?Subroutine6
      16  ?_0
      16  ?_1
    3424  OSCPUUsage
          OSStatRdy
          OSIntNesting
          OSLockNesting
          OSPrioCur
          OSPrioHighRdy
          OSRdyGrp
          OSRunning
          OSTaskCtr
          OSTickStepState
          OSRdyTbl
          OSCtxSwCtr
          OSEventFreeList
          OSIdleCtrMax
          OSIdleCtrRun
          OSIdleCtr
          OSTCBCur
          OSTCBFreeList
          OSTCBHighRdy
          OSTCBList
          OSTime
          OSEventTbl
          OSTaskStatStk
          OSTaskIdleStk
          OSTCBTbl
      60  OSEventNameGet
      74  OSEventNameSet
     394  OSEventPendMulti
       4  OSFlagFreeList
     140  OSFlagTbl
     280  OSInit
      22  OSIntEnter
      74  OSIntExit
      30  OSSchedLock
      46  OSSchedUnlock
      40  OSStart
      42  OSStatInit
     128  OSTCBPrioTbl
     136  OSTimeTick
     256  OSUnMapTbl
       6  OSVersion
       2  OS_Dummy
     104  OS_EventTaskRdy
      32  OS_EventTaskRemove
      44  OS_EventTaskRemoveMulti
      40  OS_EventTaskWait
      60  OS_EventTaskWaitMulti
      12  OS_EventWaitListInit
      10  OS_MemClr
      20  OS_MemCopy
      56  OS_Sched
      24  OS_SchedNew
      32  OS_StrCopy
      20  OS_StrLen
     228  OS_TCBInit
      24  OS_TaskIdle
      84  OS_TaskStat
      54  OS_TaskStatStkChk

 
 3'696 bytes in section .bss
   256 bytes in section .rodata
 2'184 bytes in section .text
 
 2'184 bytes of CODE  memory
   256 bytes of CONST memory
 3'696 bytes of DATA  memory

Errors: none
Warnings: none
