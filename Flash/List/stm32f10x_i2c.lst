###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.2.214/W32 for ARM         23/Dec/2019  14:43:41
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        C:\Baby\test02\exam\ett\Micrium\Software\CPU\ST\STM32\src\stm32f10x_i2c.c
#    Command line =
#        -f C:\Users\hn829\AppData\Local\Temp\EW2DBB.tmp
#        (C:\Baby\test02\exam\ett\Micrium\Software\CPU\ST\STM32\src\stm32f10x_i2c.c
#        -lCN
#        C:\Baby\test02\exam\ett\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\List
#        -o
#        C:\Baby\test02\exam\ett\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\Obj
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.3\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Baby\test02\exam\ett\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\
#        -I
#        C:\Baby\test02\exam\ett\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\ucos-ii\ports\arm-cortex-m3\generic\iar\
#        -I
#        C:\Baby\test02\exam\ett\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\ucos-ii\source\
#        -I
#        C:\Baby\test02\exam\ett\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uc-lib\
#        -I
#        C:\Baby\test02\exam\ett\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uc-cpu\
#        -I
#        C:\Baby\test02\exam\ett\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uc-cpu\ARM-Cortex-M3\IAR\
#        -I
#        C:\Baby\test02\exam\ett\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\cpu\st\stm32\inc\
#        -I
#        C:\Baby\test02\exam\ett\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\BSP\
#        -I
#        C:\Baby\test02\exam\ett\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Source\
#        -I
#        C:\Baby\test02\exam\ett\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\ST\STM32\
#        -I
#        C:\Baby\test02\exam\ett\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Communication\Generic\Source\
#        -I
#        C:\Baby\test02\exam\ett\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Plugins\uCOS-II\
#        -Ohz --use_c++_inline)
#    Locale       =  C
#    List file    =
#        C:\Baby\test02\exam\ett\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\List\stm32f10x_i2c.lst
#    Object file  =
#        C:\Baby\test02\exam\ett\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\Obj\stm32f10x_i2c.o
#
###############################################################################

C:\Baby\test02\exam\ett\Micrium\Software\CPU\ST\STM32\src\stm32f10x_i2c.c
      1          /******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
      2          * File Name          : stm32f10x_i2c.c
      3          * Author             : MCD Application Team
      4          * Version            : V2.0
      5          * Date               : 05/23/2008
      6          * Description        : This file provides all the I2C firmware functions.
      7          ********************************************************************************
      8          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
      9          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     10          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     11          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     12          * CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     13          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     14          * FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED 
     15          * IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
     16          *******************************************************************************/
     17          
     18          /* Includes ------------------------------------------------------------------*/
     19          #include "stm32f10x_i2c.h"
     20          #include "stm32f10x_rcc.h"
     21          	 
     22          /* Private typedef -----------------------------------------------------------*/
     23          /* Private define ------------------------------------------------------------*/
     24          /* I2C SPE mask */
     25          #define CR1_PE_Set              ((u16)0x0001)
     26          #define CR1_PE_Reset            ((u16)0xFFFE)
     27          
     28          /* I2C START mask */
     29          #define CR1_START_Set           ((u16)0x0100)
     30          #define CR1_START_Reset         ((u16)0xFEFF)
     31          
     32          /* I2C STOP mask */
     33          #define CR1_STOP_Set            ((u16)0x0200)
     34          #define CR1_STOP_Reset          ((u16)0xFDFF)
     35          
     36          /* I2C ACK mask */
     37          #define CR1_ACK_Set             ((u16)0x0400)
     38          #define CR1_ACK_Reset           ((u16)0xFBFF)
     39          
     40          /* I2C ENGC mask */
     41          #define CR1_ENGC_Set            ((u16)0x0040)
     42          #define CR1_ENGC_Reset          ((u16)0xFFBF)
     43          
     44          /* I2C SWRST mask */
     45          #define CR1_SWRST_Set           ((u16)0x8000)
     46          #define CR1_SWRST_Reset         ((u16)0x7FFF)
     47          
     48          /* I2C PEC mask */
     49          #define CR1_PEC_Set             ((u16)0x1000)
     50          #define CR1_PEC_Reset           ((u16)0xEFFF)
     51          
     52          /* I2C ENPEC mask */
     53          #define CR1_ENPEC_Set           ((u16)0x0020)
     54          #define CR1_ENPEC_Reset         ((u16)0xFFDF)
     55          
     56          /* I2C ENARP mask */
     57          #define CR1_ENARP_Set           ((u16)0x0010)
     58          #define CR1_ENARP_Reset         ((u16)0xFFEF)
     59          
     60          /* I2C NOSTRETCH mask */
     61          #define CR1_NOSTRETCH_Set       ((u16)0x0080)
     62          #define CR1_NOSTRETCH_Reset     ((u16)0xFF7F)
     63          
     64          /* I2C registers Masks */
     65          #define CR1_CLEAR_Mask          ((u16)0xFBF5)
     66          
     67          /* I2C DMAEN mask */
     68          #define CR2_DMAEN_Set           ((u16)0x0800)
     69          #define CR2_DMAEN_Reset         ((u16)0xF7FF)
     70          
     71          /* I2C LAST mask */
     72          #define CR2_LAST_Set            ((u16)0x1000)
     73          #define CR2_LAST_Reset          ((u16)0xEFFF)
     74          
     75          /* I2C FREQ mask */
     76          #define CR2_FREQ_Reset          ((u16)0xFFC0)
     77          
     78          /* I2C ADD0 mask */
     79          #define OAR1_ADD0_Set           ((u16)0x0001)
     80          #define OAR1_ADD0_Reset         ((u16)0xFFFE)
     81          
     82          /* I2C ENDUAL mask */
     83          #define OAR2_ENDUAL_Set         ((u16)0x0001)
     84          #define OAR2_ENDUAL_Reset       ((u16)0xFFFE)
     85          
     86          /* I2C ADD2 mask */
     87          #define OAR2_ADD2_Reset         ((u16)0xFF01)
     88          
     89          /* I2C F/S mask */
     90          #define CCR_FS_Set              ((u16)0x8000)
     91          
     92          /* I2C CCR mask */
     93          #define CCR_CCR_Set             ((u16)0x0FFF)
     94          
     95          /* I2C FLAG mask */
     96          #define FLAG_Mask               ((u32)0x00FFFFFF)
     97          
     98          /* Private macro -------------------------------------------------------------*/
     99          /* Private variables ---------------------------------------------------------*/
    100          /* Private function prototypes -----------------------------------------------*/
    101          /* Private functions ---------------------------------------------------------*/
    102          
    103          /*******************************************************************************
    104          * Function Name  : I2C_DeInit
    105          * Description    : Deinitializes the I2Cx peripheral registers to their default
    106          *                  reset values.
    107          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    108          * Output         : None
    109          * Return         : None
    110          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    111          void I2C_DeInit(I2C_TypeDef* I2Cx)
    112          {
   \                     I2C_DeInit: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    113            /* Check the parameters */
    114            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    115          
    116            switch (*(u32*)&I2Cx)
   \        0x2   0x....             LDR.N    R1,??DataTable1  ;; 0x40005400
   \        0x4   0x4288             CMP      R0,R1
   \        0x6   0xD003             BEQ.N    ??I2C_DeInit_0
   \        0x8   0x....             LDR.N    R1,??DataTable1_1  ;; 0x40005800
   \        0xA   0x4288             CMP      R0,R1
   \        0xC   0xD009             BEQ.N    ??I2C_DeInit_1
   \        0xE   0xBD01             POP      {R0,PC}
    117            {
    118              case I2C1_BASE:
    119                /* Enable I2C1 reset state */
    120                RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
   \                     ??I2C_DeInit_0: (+1)
   \       0x10   0x2101             MOVS     R1,#+1
   \       0x12   0xF44F 0x1000      MOV      R0,#+2097152
   \       0x16   0x....'....        BL       RCC_APB1PeriphResetCmd
    121                /* Release I2C1 from reset state */
    122                RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);
   \       0x1A   0x2100             MOVS     R1,#+0
   \       0x1C   0xF44F 0x1000      MOV      R0,#+2097152
   \       0x20   0xE007             B.N      ??I2C_DeInit_2
    123                break;
    124          
    125              case I2C2_BASE:
    126                /* Enable I2C2 reset state */
    127                RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
   \                     ??I2C_DeInit_1: (+1)
   \       0x22   0x2101             MOVS     R1,#+1
   \       0x24   0xF44F 0x0080      MOV      R0,#+4194304
   \       0x28   0x....'....        BL       RCC_APB1PeriphResetCmd
    128                /* Release I2C2 from reset state */
    129                RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);
   \       0x2C   0x2100             MOVS     R1,#+0
   \       0x2E   0xF44F 0x0080      MOV      R0,#+4194304
   \                     ??I2C_DeInit_2: (+1)
   \       0x32   0xE8BD 0x4004      POP      {R2,LR}
   \       0x36   0x....'....        B.W      RCC_APB1PeriphResetCmd
    130                break;
    131          
    132              default:
    133                break;
    134            }
    135          }
    136          
    137          /*******************************************************************************
    138          * Function Name  : I2C_Init
    139          * Description    : Initializes the I2Cx peripheral according to the specified 
    140          *                  parameters in the I2C_InitStruct.
    141          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    142          *                  - I2C_InitStruct: pointer to a I2C_InitTypeDef structure that
    143          *                    contains the configuration information for the specified
    144          *                    I2C peripheral.
    145          * Output         : None
    146          * Return         : None
    147          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    148          void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
    149          {
   \                     I2C_Init: (+1)
   \        0x0   0xB578             PUSH     {R3-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0xB085             SUB      SP,SP,#+20
    150            u16 tmpreg = 0, freqrange = 0;
    151            u16 result = 0x04;
    152            u32 pclk1 = 8000000;
    153            RCC_ClocksTypeDef  rcc_clocks;
    154          
    155            /* Check the parameters */
    156            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    157            assert_param(IS_I2C_MODE(I2C_InitStruct->I2C_Mode));
    158            assert_param(IS_I2C_DUTY_CYCLE(I2C_InitStruct->I2C_DutyCycle));
    159            assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct->I2C_OwnAddress1));
    160            assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));
    161            assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));
    162            assert_param(IS_I2C_CLOCK_SPEED(I2C_InitStruct->I2C_ClockSpeed));
    163          
    164          /*---------------------------- I2Cx CR2 Configuration ------------------------*/
    165            /* Get the I2Cx CR2 value */
    166            tmpreg = I2Cx->CR2;
   \        0x6   0x88A6             LDRH     R6,[R4, #+4]
   \        0x8   0x460D             MOV      R5,R1
    167            /* Clear frequency FREQ[5:0] bits */
    168            tmpreg &= CR2_FREQ_Reset;
    169            /* Get pclk1 frequency value */
    170            RCC_GetClocksFreq(&rcc_clocks);
   \        0xA   0x4668             MOV      R0,SP
   \        0xC   0x....'....        BL       RCC_GetClocksFreq
    171            pclk1 = rcc_clocks.PCLK1_Frequency;
   \       0x10   0x9B02             LDR      R3,[SP, #+8]
    172            /* Set frequency bits depending on pclk1 value */
    173            freqrange = (u16)(pclk1 / 1000000);
   \       0x12   0x....             LDR.N    R0,??DataTable1_2  ;; 0xf4240
    174            tmpreg |= freqrange;
    175            /* Write to I2Cx CR2 */
    176            I2Cx->CR2 = tmpreg;
   \       0x14   0xF64F 0x71C0      MOVW     R1,#+65472
   \       0x18   0xFBB3 0xF2F0      UDIV     R2,R3,R0
   \       0x1C   0x400E             ANDS     R6,R1,R6
   \       0x1E   0x4316             ORRS     R6,R2,R6
   \       0x20   0x80A6             STRH     R6,[R4, #+4]
    177          
    178          /*---------------------------- I2Cx CCR Configuration ------------------------*/
    179            /* Disable the selected I2C peripheral to configure TRISE */
    180            I2Cx->CR1 &= CR1_PE_Reset;
   \       0x22   0xF64F 0x70FE      MOVW     R0,#+65534
   \       0x26   0x8826             LDRH     R6,[R4, #+0]
   \       0x28   0x4006             ANDS     R6,R0,R6
   \       0x2A   0x8026             STRH     R6,[R4, #+0]
    181          
    182            /* Reset tmpreg value */
    183            /* Clear F/S, DUTY and CCR[11:0] bits */
    184            tmpreg = 0;
    185          
    186            /* Configure speed in standard mode */
    187            if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
   \       0x2C   0x68E9             LDR      R1,[R5, #+12]
   \       0x2E   0x....             LDR.N    R6,??DataTable1_3  ;; 0x186a1
   \       0x30   0x42B1             CMP      R1,R6
   \       0x32   0xD207             BCS.N    ??I2C_Init_0
    188            {
    189              /* Standard mode speed calculate */
    190              result = (u16)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
   \       0x34   0x0049             LSLS     R1,R1,#+1
   \       0x36   0xFBB3 0xF1F1      UDIV     R1,R3,R1
    191              /* Test if CCR value is under 0x4*/
    192              if (result < 0x04)
   \       0x3A   0xB288             UXTH     R0,R1
   \       0x3C   0x2804             CMP      R0,#+4
   \       0x3E   0xDA20             BGE.N    ??I2C_Init_1
    193              {
    194                /* Set minimum allowed value */
    195                result = 0x04;  
   \       0x40   0x2104             MOVS     R1,#+4
    196              }
    197              /* Set speed value for standard mode */
    198              tmpreg |= result;	  
    199              /* Set Maximum Rise Time for standard mode */
    200              I2Cx->TRISE = freqrange + 1; 
   \       0x42   0xE01E             B.N      ??I2C_Init_1
    201            }
    202            /* Configure speed in fast mode */
    203            else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
    204            {
    205              if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
   \                     ??I2C_Init_0: (+1)
   \       0x44   0x8868             LDRH     R0,[R5, #+2]
   \       0x46   0xF64B 0x76FF      MOVW     R6,#+49151
   \       0x4A   0x42B0             CMP      R0,R6
   \       0x4C   0xD104             BNE.N    ??I2C_Init_2
    206              {
    207                /* Fast mode speed calculate: Tlow/Thigh = 2 */
    208                result = (u16)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
   \       0x4E   0xEB01 0x0141      ADD      R1,R1,R1, LSL #+1
   \       0x52   0xFBB3 0xF1F1      UDIV     R1,R3,R1
   \       0x56   0xE006             B.N      ??I2C_Init_3
    209              }
    210              else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/
    211              {
    212                /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
    213                result = (u16)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
    214                /* Set DUTY bit */
    215                result |= I2C_DutyCycle_16_9;
   \                     ??I2C_Init_2: (+1)
   \       0x58   0x2019             MOVS     R0,#+25
   \       0x5A   0x4341             MULS     R1,R0,R1
   \       0x5C   0xFBB3 0xF1F1      UDIV     R1,R3,R1
   \       0x60   0xF441 0x4180      ORR      R1,R1,#0x4000
   \       0x64   0xB289             UXTH     R1,R1
    216              }
    217              /* Test if CCR value is under 0x1*/
    218              if ((result & CCR_CCR_Set) == 0)
   \                     ??I2C_Init_3: (+1)
   \       0x66   0x0508             LSLS     R0,R1,#+20
    219              {
    220                /* Set minimum allowed value */
    221                result |= (u16)0x0001;  
    222              }
    223              /* Set speed value and set F/S bit for fast mode */
    224              tmpreg |= result | CCR_FS_Set;
    225              /* Set Maximum Rise Time for fast mode */
    226              I2Cx->TRISE = (u16)(((freqrange * 300) / 1000) + 1);  
   \       0x68   0xB292             UXTH     R2,R2
   \       0x6A   0xF44F 0x7096      MOV      R0,#+300
   \       0x6E   0xBF08             IT       EQ 
   \       0x70   0xF041 0x0101      ORREQ    R1,R1,#0x1
   \       0x74   0x4342             MULS     R2,R0,R2
   \       0x76   0xF44F 0x737A      MOV      R3,#+1000
   \       0x7A   0xF441 0x4100      ORR      R1,R1,#0x8000
   \       0x7E   0xFB92 0xF2F3      SDIV     R2,R2,R3
   \                     ??I2C_Init_1: (+1)
   \       0x82   0x1C52             ADDS     R2,R2,#+1
   \       0x84   0x8422             STRH     R2,[R4, #+32]
    227            }
    228            /* Write to I2Cx CCR */
    229            I2Cx->CCR = tmpreg;
   \       0x86   0x83A1             STRH     R1,[R4, #+28]
    230          
    231            /* Enable the selected I2C peripheral */
    232            I2Cx->CR1 |= CR1_PE_Set;
    233          
    234          /*---------------------------- I2Cx CR1 Configuration ------------------------*/
    235            /* Get the I2Cx CR1 value */
    236            tmpreg = I2Cx->CR1;
    237            /* Clear ACK, SMBTYPE and  SMBUS bits */
    238            tmpreg &= CR1_CLEAR_Mask;
    239            /* Configure I2Cx: mode and acknowledgement */
    240            /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
    241            /* Set ACK bit according to I2C_Ack value */
    242            tmpreg |= (u16)((u32)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
    243            /* Write to I2Cx CR1 */
    244            I2Cx->CR1 = tmpreg;
   \       0x88   0xF64F 0x32F5      MOVW     R2,#+64501
   \       0x8C   0x8820             LDRH     R0,[R4, #+0]
   \       0x8E   0xF040 0x0001      ORR      R0,R0,#0x1
   \       0x92   0x8020             STRH     R0,[R4, #+0]
   \       0x94   0x8823             LDRH     R3,[R4, #+0]
   \       0x96   0x8829             LDRH     R1,[R5, #+0]
   \       0x98   0x88E8             LDRH     R0,[R5, #+6]
   \       0x9A   0x4013             ANDS     R3,R2,R3
   \       0x9C   0x430B             ORRS     R3,R1,R3
   \       0x9E   0x4303             ORRS     R3,R0,R3
   \       0xA0   0x8023             STRH     R3,[R4, #+0]
    245          
    246          /*---------------------------- I2Cx OAR1 Configuration -----------------------*/
    247            /* Set I2Cx Own Address1 and acknowledged address */
    248            I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
   \       0xA2   0x8929             LDRH     R1,[R5, #+8]
   \       0xA4   0x88A8             LDRH     R0,[R5, #+4]
   \       0xA6   0x4301             ORRS     R1,R0,R1
   \       0xA8   0x8121             STRH     R1,[R4, #+8]
    249          }
   \       0xAA   0xB006             ADD      SP,SP,#+24
   \       0xAC   0xBD70             POP      {R4-R6,PC}       ;; return
    250          
    251          /*******************************************************************************
    252          * Function Name  : I2C_StructInit
    253          * Description    : Fills each I2C_InitStruct member with its default value.
    254          * Input          : - I2C_InitStruct: pointer to an I2C_InitTypeDef structure
    255          *                    which will be initialized.
    256          * Output         : None
    257          * Return         : None
    258          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    259          void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
    260          {
    261          /*---------------- Reset I2C init structure parameters values ----------------*/
    262            /* Initialize the I2C_Mode member */
    263            I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
   \                     I2C_StructInit: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x8001             STRH     R1,[R0, #+0]
    264          
    265            /* Initialize the I2C_DutyCycle member */
    266            I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
   \        0x4   0xF64B 0x72FF      MOVW     R2,#+49151
   \        0x8   0x8042             STRH     R2,[R0, #+2]
    267          
    268            /* Initialize the I2C_OwnAddress1 member */
    269            I2C_InitStruct->I2C_OwnAddress1 = 0;
   \        0xA   0x8081             STRH     R1,[R0, #+4]
    270          
    271            /* Initialize the I2C_Ack member */
    272            I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
   \        0xC   0x80C1             STRH     R1,[R0, #+6]
    273          
    274            /* Initialize the I2C_AcknowledgedAddress member */
    275            I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
   \        0xE   0xF44F 0x4280      MOV      R2,#+16384
    276          
    277            /* initialize the I2C_ClockSpeed member */
    278            I2C_InitStruct->I2C_ClockSpeed = 5000;
   \       0x12   0xF241 0x3188      MOVW     R1,#+5000
   \       0x16   0x8102             STRH     R2,[R0, #+8]
   \       0x18   0x60C1             STR      R1,[R0, #+12]
    279          }
   \       0x1A   0x4770             BX       LR               ;; return
    280          
    281          /*******************************************************************************
    282          * Function Name  : I2C_Cmd
    283          * Description    : Enables or disables the specified I2C peripheral.
    284          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    285          *                  - NewState: new state of the I2Cx peripheral. This parameter
    286          *                    can be: ENABLE or DISABLE.
    287          * Output         : None
    288          * Return         : None
    289          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    290          void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    291          {
    292            /* Check the parameters */
    293            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    294            assert_param(IS_FUNCTIONAL_STATE(NewState));
    295          
    296            if (NewState != DISABLE)
   \                     I2C_Cmd: (+1)
   \        0x0   0xB121             CBZ.N    R1,??I2C_Cmd_0
    297            {
    298              /* Enable the selected I2C peripheral */
    299              I2Cx->CR1 |= CR1_PE_Set;
   \        0x2   0x8801             LDRH     R1,[R0, #+0]
   \        0x4   0xF041 0x0101      ORR      R1,R1,#0x1
   \        0x8   0x8001             STRH     R1,[R0, #+0]
   \        0xA   0x4770             BX       LR
    300            }
    301            else
    302            {
    303              /* Disable the selected I2C peripheral */
    304              I2Cx->CR1 &= CR1_PE_Reset;
   \                     ??I2C_Cmd_0: (+1)
   \        0xC   0x8802             LDRH     R2,[R0, #+0]
   \        0xE   0xF64F 0x71FE      MOVW     R1,#+65534
   \       0x12   0x....             B.N      ?Subroutine1
    305            }
    306          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x400A             ANDS     R2,R1,R2
   \        0x2   0x8002             STRH     R2,[R0, #+0]
   \        0x4   0x4770             BX       LR               ;; return
    307          
    308          /*******************************************************************************
    309          * Function Name  : I2C_DMACmd
    310          * Description    : Enables or disables the specified I2C DMA requests.
    311          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    312          *                  - NewState: new state of the I2C DMA transfer.
    313          *                    This parameter can be: ENABLE or DISABLE.
    314          * Output         : None
    315          * Return         : None
    316          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    317          void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    318          {
    319            /* Check the parameters */
    320            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    321            assert_param(IS_FUNCTIONAL_STATE(NewState));
    322          
    323            if (NewState != DISABLE)
   \                     I2C_DMACmd: (+1)
   \        0x0   0xB121             CBZ.N    R1,??I2C_DMACmd_0
    324            {
    325              /* Enable the selected I2C DMA requests */
    326              I2Cx->CR2 |= CR2_DMAEN_Set;
   \        0x2   0x8881             LDRH     R1,[R0, #+4]
   \        0x4   0xF441 0x6100      ORR      R1,R1,#0x800
   \        0x8   0x8081             STRH     R1,[R0, #+4]
   \        0xA   0x4770             BX       LR
    327            }
    328            else
    329            {
    330              /* Disable the selected I2C DMA requests */
    331              I2Cx->CR2 &= CR2_DMAEN_Reset;
   \                     ??I2C_DMACmd_0: (+1)
   \        0xC   0x8882             LDRH     R2,[R0, #+4]
   \        0xE   0xF24F 0x71FF      MOVW     R1,#+63487
   \       0x12   0x....             B.N      ?Subroutine2
    332            }
    333          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x400A             ANDS     R2,R1,R2
   \        0x2   0x8082             STRH     R2,[R0, #+4]
   \        0x4   0x4770             BX       LR               ;; return
    334          
    335          /*******************************************************************************
    336          * Function Name  : I2C_DMALastTransferCmd
    337          * Description    : Specifies that the next DMA transfer is the last one.
    338          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    339          *                  - NewState: new state of the I2C DMA last transfer.
    340          *                    This parameter can be: ENABLE or DISABLE.
    341          * Output         : None
    342          * Return         : None
    343          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    344          void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    345          {
    346            /* Check the parameters */
    347            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    348            assert_param(IS_FUNCTIONAL_STATE(NewState));
    349          
    350            if (NewState != DISABLE)
   \                     I2C_DMALastTransferCmd: (+1)
   \        0x0   0xB121             CBZ.N    R1,??I2C_DMALastTransferCmd_0
    351            {
    352              /* Next DMA transfer is the last transfer */
    353              I2Cx->CR2 |= CR2_LAST_Set;
   \        0x2   0x8881             LDRH     R1,[R0, #+4]
   \        0x4   0xF441 0x5180      ORR      R1,R1,#0x1000
   \        0x8   0x8081             STRH     R1,[R0, #+4]
   \        0xA   0x4770             BX       LR
    354            }
    355            else
    356            {
    357              /* Next DMA transfer is not the last transfer */
    358              I2Cx->CR2 &= CR2_LAST_Reset;
   \                     ??I2C_DMALastTransferCmd_0: (+1)
   \        0xC   0x8882             LDRH     R2,[R0, #+4]
   \        0xE   0xF64E 0x71FF      MOVW     R1,#+61439
   \       0x12                      REQUIRE ?Subroutine2
   \       0x12                      ;; // Fall through to label ?Subroutine2
    359            }
    360          }
    361          
    362          /*******************************************************************************
    363          * Function Name  : I2C_GenerateSTART
    364          * Description    : Generates I2Cx communication START condition.
    365          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    366          *                  - NewState: new state of the I2C START condition generation.
    367          *                    This parameter can be: ENABLE or DISABLE.
    368          * Output         : None
    369          * Return         : None.
    370          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    371          void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
    372          {
    373            /* Check the parameters */
    374            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    375            assert_param(IS_FUNCTIONAL_STATE(NewState));
    376          
    377            if (NewState != DISABLE)
   \                     I2C_GenerateSTART: (+1)
   \        0x0   0xB121             CBZ.N    R1,??I2C_GenerateSTART_0
    378            {
    379              /* Generate a START condition */
    380              I2Cx->CR1 |= CR1_START_Set;
   \        0x2   0x8801             LDRH     R1,[R0, #+0]
   \        0x4   0xF441 0x7180      ORR      R1,R1,#0x100
   \        0x8   0x8001             STRH     R1,[R0, #+0]
   \        0xA   0x4770             BX       LR
    381            }
    382            else
    383            {
    384              /* Disable the START condition generation */
    385              I2Cx->CR1 &= CR1_START_Reset;
   \                     ??I2C_GenerateSTART_0: (+1)
   \        0xC   0x8802             LDRH     R2,[R0, #+0]
   \        0xE   0xF64F 0x61FF      MOVW     R1,#+65279
   \       0x12                      REQUIRE ?Subroutine1
   \       0x12                      ;; // Fall through to label ?Subroutine1
    386            }
    387          }
    388          
    389          /*******************************************************************************
    390          * Function Name  : I2C_GenerateSTOP
    391          * Description    : Generates I2Cx communication STOP condition.
    392          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    393          *                  - NewState: new state of the I2C STOP condition generation.
    394          *                    This parameter can be: ENABLE or DISABLE.
    395          * Output         : None
    396          * Return         : None.
    397          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    398          void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
    399          {
    400            /* Check the parameters */
    401            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    402            assert_param(IS_FUNCTIONAL_STATE(NewState));
    403          
    404            if (NewState != DISABLE)
   \                     I2C_GenerateSTOP: (+1)
   \        0x0   0xB121             CBZ.N    R1,??I2C_GenerateSTOP_0
    405            {
    406              /* Generate a STOP condition */
    407              I2Cx->CR1 |= CR1_STOP_Set;
   \        0x2   0x8801             LDRH     R1,[R0, #+0]
   \        0x4   0xF441 0x7100      ORR      R1,R1,#0x200
   \        0x8   0x8001             STRH     R1,[R0, #+0]
   \        0xA   0x4770             BX       LR
    408            }
    409            else
    410            {
    411              /* Disable the STOP condition generation */
    412              I2Cx->CR1 &= CR1_STOP_Reset;
   \                     ??I2C_GenerateSTOP_0: (+1)
   \        0xC   0x8802             LDRH     R2,[R0, #+0]
   \        0xE   0xF64F 0x51FF      MOVW     R1,#+65023
   \       0x12   0x....             B.N      ?Subroutine1
    413            }
    414          }
    415          
    416          /*******************************************************************************
    417          * Function Name  : I2C_AcknowledgeConfig
    418          * Description    : Enables or disables the specified I2C acknowledge feature.
    419          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    420          *                  - NewState: new state of the I2C Acknowledgement.
    421          *                    This parameter can be: ENABLE or DISABLE.
    422          * Output         : None
    423          * Return         : None.
    424          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    425          void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
    426          {
    427            /* Check the parameters */
    428            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    429            assert_param(IS_FUNCTIONAL_STATE(NewState));
    430          
    431            if (NewState != DISABLE)
   \                     I2C_AcknowledgeConfig: (+1)
   \        0x0   0xB121             CBZ.N    R1,??I2C_AcknowledgeConfig_0
    432            {
    433              /* Enable the acknowledgement */
    434              I2Cx->CR1 |= CR1_ACK_Set;
   \        0x2   0x8801             LDRH     R1,[R0, #+0]
   \        0x4   0xF441 0x6180      ORR      R1,R1,#0x400
   \        0x8   0x8001             STRH     R1,[R0, #+0]
   \        0xA   0x4770             BX       LR
    435            }
    436            else
    437            {
    438              /* Disable the acknowledgement */
    439              I2Cx->CR1 &= CR1_ACK_Reset;
   \                     ??I2C_AcknowledgeConfig_0: (+1)
   \        0xC   0x8802             LDRH     R2,[R0, #+0]
   \        0xE   0xF64F 0x31FF      MOVW     R1,#+64511
   \       0x12   0x....             B.N      ?Subroutine1
    440            }
    441          }
    442          
    443          /*******************************************************************************
    444          * Function Name  : I2C_OwnAddress2Config
    445          * Description    : Configures the specified I2C own address2.
    446          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    447          *                  - Address: specifies the 7bit I2C own address2.
    448          * Output         : None
    449          * Return         : None.
    450          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    451          void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, u8 Address)
    452          {
    453            u16 tmpreg = 0;
    454          
    455            /* Check the parameters */
    456            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    457          
    458            /* Get the old register value */
    459            tmpreg = I2Cx->OAR2;
    460            /* Reset I2Cx Own address2 bit [7:1] */
    461            tmpreg &= OAR2_ADD2_Reset;
    462            /* Set I2Cx Own address2 */
    463            tmpreg |= (u16)(Address & (u16)0x00FE);
    464            /* Store the new register value */
    465            I2Cx->OAR2 = tmpreg;
   \                     I2C_OwnAddress2Config: (+1)
   \        0x0   0x8983             LDRH     R3,[R0, #+12]
   \        0x2   0xF64F 0x7201      MOVW     R2,#+65281
   \        0x6   0x4013             ANDS     R3,R2,R3
   \        0x8   0xF001 0x01FE      AND      R1,R1,#0xFE
   \        0xC   0x4319             ORRS     R1,R1,R3
   \        0xE   0x8181             STRH     R1,[R0, #+12]
    466          }
   \       0x10   0x4770             BX       LR               ;; return
    467          
    468          /*******************************************************************************
    469          * Function Name  : I2C_DualAddressCmd
    470          * Description    : Enables or disables the specified I2C dual addressing mode.
    471          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    472          *                  - NewState: new state of the I2C dual addressing mode.
    473          *                    This parameter can be: ENABLE or DISABLE.
    474          * Output         : None
    475          * Return         : None
    476          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    477          void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    478          {
    479            /* Check the parameters */
    480            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    481            assert_param(IS_FUNCTIONAL_STATE(NewState));
    482          
    483            if (NewState != DISABLE)
   \                     I2C_DualAddressCmd: (+1)
   \        0x0   0xB121             CBZ.N    R1,??I2C_DualAddressCmd_0
    484            {
    485              /* Enable dual addressing mode */
    486              I2Cx->OAR2 |= OAR2_ENDUAL_Set;
   \        0x2   0x8981             LDRH     R1,[R0, #+12]
   \        0x4   0xF041 0x0101      ORR      R1,R1,#0x1
   \        0x8   0x8181             STRH     R1,[R0, #+12]
   \        0xA   0x4770             BX       LR
    487            }
    488            else
    489            {
    490              /* Disable dual addressing mode */
    491              I2Cx->OAR2 &= OAR2_ENDUAL_Reset;
   \                     ??I2C_DualAddressCmd_0: (+1)
   \        0xC   0x8982             LDRH     R2,[R0, #+12]
   \        0xE   0xF64F 0x71FE      MOVW     R1,#+65534
   \       0x12   0x400A             ANDS     R2,R1,R2
   \       0x14   0x8182             STRH     R2,[R0, #+12]
    492            }
    493          }
   \       0x16   0x4770             BX       LR               ;; return
    494          
    495          /*******************************************************************************
    496          * Function Name  : I2C_GeneralCallCmd
    497          * Description    : Enables or disables the specified I2C general call feature.
    498          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    499          *                  - NewState: new state of the I2C General call.
    500          *                    This parameter can be: ENABLE or DISABLE.
    501          * Output         : None
    502          * Return         : None
    503          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    504          void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    505          {
    506            /* Check the parameters */
    507            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    508            assert_param(IS_FUNCTIONAL_STATE(NewState));
    509          
    510            if (NewState != DISABLE)
   \                     I2C_GeneralCallCmd: (+1)
   \        0x0   0xB121             CBZ.N    R1,??I2C_GeneralCallCmd_0
    511            {
    512              /* Enable generall call */
    513              I2Cx->CR1 |= CR1_ENGC_Set;
   \        0x2   0x8801             LDRH     R1,[R0, #+0]
   \        0x4   0xF041 0x0140      ORR      R1,R1,#0x40
   \        0x8   0x8001             STRH     R1,[R0, #+0]
   \        0xA   0x4770             BX       LR
    514            }
    515            else
    516            {
    517              /* Disable generall call */
    518              I2Cx->CR1 &= CR1_ENGC_Reset;
   \                     ??I2C_GeneralCallCmd_0: (+1)
   \        0xC   0x8802             LDRH     R2,[R0, #+0]
   \        0xE   0xF64F 0x71BF      MOVW     R1,#+65471
   \       0x12   0x....             B.N      ?Subroutine1
    519            }
    520          }
    521          
    522          /*******************************************************************************
    523          * Function Name  : I2C_ITConfig
    524          * Description    : Enables or disables the specified I2C interrupts.
    525          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    526          *                  - I2C_IT: specifies the I2C interrupts sources to be enabled
    527          *                    or disabled. 
    528          *                    This parameter can be any combination of the following values:
    529          *                       - I2C_IT_BUF: Buffer interrupt mask
    530          *                       - I2C_IT_EVT: Event interrupt mask
    531          *                       - I2C_IT_ERR: Error interrupt mask
    532          *                  - NewState: new state of the specified I2C interrupts.
    533          *                    This parameter can be: ENABLE or DISABLE.
    534          * Output         : None
    535          * Return         : None
    536          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    537          void I2C_ITConfig(I2C_TypeDef* I2Cx, u16 I2C_IT, FunctionalState NewState)
    538          {
    539            /* Check the parameters */
    540            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    541            assert_param(IS_FUNCTIONAL_STATE(NewState));
    542            assert_param(IS_I2C_CONFIG_IT(I2C_IT));
    543            
    544            if (NewState != DISABLE)
   \                     I2C_ITConfig: (+1)
   \        0x0   0x2A00             CMP      R2,#+0
   \        0x2   0x8882             LDRH     R2,[R0, #+4]
   \        0x4   0xBF14             ITE      NE 
   \        0x6   0x4311             ORRNE    R1,R1,R2
   \        0x8   0xEA22 0x0101      BICEQ    R1,R2,R1
    545            {
    546              /* Enable the selected I2C interrupts */
    547              I2Cx->CR2 |= I2C_IT;
    548            }
    549            else
    550            {
    551              /* Disable the selected I2C interrupts */
    552              I2Cx->CR2 &= (u16)~I2C_IT;
   \        0xC   0x8081             STRH     R1,[R0, #+4]
    553            }
    554          }
   \        0xE   0x4770             BX       LR               ;; return
    555          
    556          /*******************************************************************************
    557          * Function Name  : I2C_SendData
    558          * Description    : Sends a data byte through the I2Cx peripheral.
    559          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    560          *                  - Data: Byte to be transmitted..
    561          * Output         : None
    562          * Return         : None
    563          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    564          void I2C_SendData(I2C_TypeDef* I2Cx, u8 Data)
    565          {
    566            /* Check the parameters */
    567            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    568          
    569            /* Write in the DR register the data to be sent */
    570            I2Cx->DR = Data;
   \                     I2C_SendData: (+1)
   \        0x0   0x8201             STRH     R1,[R0, #+16]
    571          }
   \        0x2   0x4770             BX       LR               ;; return
    572          
    573          /*******************************************************************************
    574          * Function Name  : I2C_ReceiveData
    575          * Description    : Returns the most recent received data by the I2Cx peripheral.
    576          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    577          * Output         : None
    578          * Return         : The value of the received data.
    579          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    580          u8 I2C_ReceiveData(I2C_TypeDef* I2Cx)
    581          {
    582            /* Check the parameters */
    583            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    584          
    585            /* Return the data in the DR register */
    586            return (u8)I2Cx->DR;
   \                     I2C_ReceiveData: (+1)
   \        0x0   0x8A00             LDRH     R0,[R0, #+16]
   \        0x2   0xB2C0             UXTB     R0,R0
   \        0x4   0x4770             BX       LR               ;; return
    587          }
    588          
    589          /*******************************************************************************
    590          * Function Name  : I2C_Send7bitAddress
    591          * Description    : Transmits the address byte to select the slave device.
    592          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    593          *                  - Address: specifies the slave address which will be transmitted
    594          *                  - I2C_Direction: specifies whether the I2C device will be a
    595          *                    Transmitter or a Receiver. 
    596          *                    This parameter can be one of the following values
    597          *                       - I2C_Direction_Transmitter: Transmitter mode
    598          *                       - I2C_Direction_Receiver: Receiver mode
    599          * Output         : None
    600          * Return         : None.
    601          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    602          void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, u8 Address, u8 I2C_Direction)
    603          {
    604            /* Check the parameters */
    605            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    606            assert_param(IS_I2C_DIRECTION(I2C_Direction));
    607          
    608            /* Test on the direction to set/reset the read/write bit */
    609            if (I2C_Direction != I2C_Direction_Transmitter)
   \                     I2C_Send7bitAddress: (+1)
   \        0x0   0x2A00             CMP      R2,#+0
   \        0x2   0xBF14             ITE      NE 
   \        0x4   0xF041 0x0101      ORRNE    R1,R1,#0x1
   \        0x8   0xF001 0x01FE      ANDEQ    R1,R1,#0xFE
    610            {
    611              /* Set the address bit0 for read */
    612              Address |= OAR1_ADD0_Set;
    613            }
    614            else
    615            {
    616              /* Reset the address bit0 for write */
    617              Address &= OAR1_ADD0_Reset;
    618            }
    619            /* Send the address */
    620            I2Cx->DR = Address;
   \        0xC   0x8201             STRH     R1,[R0, #+16]
    621          }
   \        0xE   0x4770             BX       LR               ;; return
    622          
    623          /*******************************************************************************
    624          * Function Name  : I2C_ReadRegister
    625          * Description    : Reads the specified I2C register and returns its value.
    626          * Input1         : - I2C_Register: specifies the register to read.
    627          *                    This parameter can be one of the following values:
    628          *                       - I2C_Register_CR1:  CR1 register.
    629          *                       - I2C_Register_CR2:   CR2 register.
    630          *                       - I2C_Register_OAR1:  OAR1 register.
    631          *                       - I2C_Register_OAR2:  OAR2 register.
    632          *                       - I2C_Register_DR:    DR register.
    633          *                       - I2C_Register_SR1:   SR1 register.
    634          *                       - I2C_Register_SR2:   SR2 register.
    635          *                       - I2C_Register_CCR:   CCR register.
    636          *                       - I2C_Register_TRISE: TRISE register.
    637          * Output         : None
    638          * Return         : The value of the read register.
    639          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    640          u16 I2C_ReadRegister(I2C_TypeDef* I2Cx, u8 I2C_Register)
    641          {
    642            /* Check the parameters */
    643            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    644            assert_param(IS_I2C_REGISTER(I2C_Register));
    645          
    646            /* Return the selected register value */
    647            return (*(vu16 *)(*((vu32 *)&I2Cx) + I2C_Register));
   \                     I2C_ReadRegister: (+1)
   \        0x0   0x1808             ADDS     R0,R1,R0
   \        0x2   0x8800             LDRH     R0,[R0, #+0]
   \        0x4   0x4770             BX       LR               ;; return
    648          }
    649          
    650          /*******************************************************************************
    651          * Function Name  : I2C_SoftwareResetCmd
    652          * Description    : Enables or disables the specified I2C software reset.
    653          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    654          *                  - NewState: new state of the I2C software reset.
    655          *                    This parameter can be: ENABLE or DISABLE.
    656          * Output         : None
    657          * Return         : None
    658          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    659          void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    660          {
    661            /* Check the parameters */
    662            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    663            assert_param(IS_FUNCTIONAL_STATE(NewState));
    664          
    665            if (NewState != DISABLE)
   \                     I2C_SoftwareResetCmd: (+1)
   \        0x0   0xB121             CBZ.N    R1,??I2C_SoftwareResetCmd_0
    666            {
    667              /* Peripheral under reset */
    668              I2Cx->CR1 |= CR1_SWRST_Set;
   \        0x2   0x8801             LDRH     R1,[R0, #+0]
   \        0x4   0xF441 0x4100      ORR      R1,R1,#0x8000
   \        0x8   0x8001             STRH     R1,[R0, #+0]
   \        0xA   0x4770             BX       LR
    669            }
    670            else
    671            {
    672              /* Peripheral not under reset */
    673              I2Cx->CR1 &= CR1_SWRST_Reset;
   \                     ??I2C_SoftwareResetCmd_0: (+1)
   \        0xC   0x8802             LDRH     R2,[R0, #+0]
   \        0xE   0xF3C2 0x020E      UBFX     R2,R2,#+0,#+15
   \       0x12   0x8002             STRH     R2,[R0, #+0]
    674            }
    675          }
   \       0x14   0x4770             BX       LR               ;; return
    676          
    677          /*******************************************************************************
    678          * Function Name  : I2C_SMBusAlertConfig
    679          * Description    : Drives the SMBusAlert pin high or low for the specified I2C.
    680          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    681          *                  - I2C_SMBusAlert: specifies SMBAlert pin level. 
    682          *                    This parameter can be one of the following values:
    683          *                       - I2C_SMBusAlert_Low: SMBAlert pin driven low
    684          *                       - I2C_SMBusAlert_High: SMBAlert pin driven high
    685          * Output         : None
    686          * Return         : None
    687          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    688          void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, u16 I2C_SMBusAlert)
    689          {
    690            /* Check the parameters */
    691            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    692            assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
    693          
    694            if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
   \                     I2C_SMBusAlertConfig: (+1)
   \        0x0   0xF5B1 0x5F00      CMP      R1,#+8192
   \        0x4   0xD104             BNE.N    ??I2C_SMBusAlertConfig_0
    695            {
    696              /* Drive the SMBusAlert pin Low */
    697              I2Cx->CR1 |= I2C_SMBusAlert_Low;
   \        0x6   0x8801             LDRH     R1,[R0, #+0]
   \        0x8   0xF441 0x5100      ORR      R1,R1,#0x2000
   \        0xC   0x8001             STRH     R1,[R0, #+0]
   \        0xE   0x4770             BX       LR
    698            }
    699            else
    700            {
    701              /* Drive the SMBusAlert pin High  */
    702              I2Cx->CR1 &= I2C_SMBusAlert_High;
   \                     ??I2C_SMBusAlertConfig_0: (+1)
   \       0x10   0x8802             LDRH     R2,[R0, #+0]
   \       0x12   0xF64D 0x71FF      MOVW     R1,#+57343
   \       0x16   0x....             B.N      ?Subroutine1
    703            }
    704          }
    705          
    706          /*******************************************************************************
    707          * Function Name  : I2C_TransmitPEC
    708          * Description    : Enables or disables the specified I2C PEC transfer.
    709          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    710          *                  - NewState: new state of the I2C PEC transmission.
    711          *                    This parameter can be: ENABLE or DISABLE.
    712          * Output         : None
    713          * Return         : None
    714          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    715          void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
    716          {
    717            /* Check the parameters */
    718            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    719            assert_param(IS_FUNCTIONAL_STATE(NewState));
    720          
    721            if (NewState != DISABLE)
   \                     I2C_TransmitPEC: (+1)
   \        0x0   0xB121             CBZ.N    R1,??I2C_TransmitPEC_0
    722            {
    723              /* Enable the selected I2C PEC transmission */
    724              I2Cx->CR1 |= CR1_PEC_Set;
   \        0x2   0x8801             LDRH     R1,[R0, #+0]
   \        0x4   0xF441 0x5180      ORR      R1,R1,#0x1000
   \        0x8   0x8001             STRH     R1,[R0, #+0]
   \        0xA   0x4770             BX       LR
    725            }
    726            else
    727            {
    728              /* Disable the selected I2C PEC transmission */
    729              I2Cx->CR1 &= CR1_PEC_Reset;
   \                     ??I2C_TransmitPEC_0: (+1)
   \        0xC   0x8802             LDRH     R2,[R0, #+0]
   \        0xE   0xF64E 0x71FF      MOVW     R1,#+61439
   \       0x12   0x....             B.N      ?Subroutine1
    730            }
    731          }
    732          
    733          /*******************************************************************************
    734          * Function Name  : I2C_PECPositionConfig
    735          * Description    : Selects the specified I2C PEC position.
    736          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    737          *                  - I2C_PECPosition: specifies the PEC position. 
    738          *                    This parameter can be one of the following values:
    739          *                       - I2C_PECPosition_Next: indicates that the next
    740          *                         byte is PEC
    741          *                       - I2C_PECPosition_Current: indicates that current
    742          *                         byte is PEC
    743          * Output         : None
    744          * Return         : None
    745          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    746          void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, u16 I2C_PECPosition)
    747          {
    748            /* Check the parameters */
    749            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    750            assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
    751          
    752            if (I2C_PECPosition == I2C_PECPosition_Next)
   \                     I2C_PECPositionConfig: (+1)
   \        0x0   0xF5B1 0x6F00      CMP      R1,#+2048
   \        0x4   0xD104             BNE.N    ??I2C_PECPositionConfig_0
    753            {
    754              /* Next byte in shift register is PEC */
    755              I2Cx->CR1 |= I2C_PECPosition_Next;
   \        0x6   0x8801             LDRH     R1,[R0, #+0]
   \        0x8   0xF441 0x6100      ORR      R1,R1,#0x800
   \        0xC   0x8001             STRH     R1,[R0, #+0]
   \        0xE   0x4770             BX       LR
    756            }
    757            else
    758            {
    759              /* Current byte in shift register is PEC */
    760              I2Cx->CR1 &= I2C_PECPosition_Current;
   \                     ??I2C_PECPositionConfig_0: (+1)
   \       0x10   0x8802             LDRH     R2,[R0, #+0]
   \       0x12   0xF24F 0x71FF      MOVW     R1,#+63487
   \       0x16   0x....             B.N      ?Subroutine1
    761            }
    762          }
    763          
    764          /*******************************************************************************
    765          * Function Name  : I2C_CalculatePEC
    766          * Description    : Enables or disables the PEC value calculation of the
    767          *                  transfered bytes.
    768          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    769          *                  - NewState: new state of the I2Cx PEC value calculation.
    770          *                    This parameter can be: ENABLE or DISABLE.
    771          * Output         : None
    772          * Return         : None
    773          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    774          void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
    775          {
    776            /* Check the parameters */
    777            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    778            assert_param(IS_FUNCTIONAL_STATE(NewState));
    779          
    780            if (NewState != DISABLE)
   \                     I2C_CalculatePEC: (+1)
   \        0x0   0xB121             CBZ.N    R1,??I2C_CalculatePEC_0
    781            {
    782              /* Enable the selected I2C PEC calculation */
    783              I2Cx->CR1 |= CR1_ENPEC_Set;
   \        0x2   0x8801             LDRH     R1,[R0, #+0]
   \        0x4   0xF041 0x0120      ORR      R1,R1,#0x20
   \        0x8   0x8001             STRH     R1,[R0, #+0]
   \        0xA   0x4770             BX       LR
    784            }
    785            else
    786            {
    787              /* Disable the selected I2C PEC calculation */
    788              I2Cx->CR1 &= CR1_ENPEC_Reset;
   \                     ??I2C_CalculatePEC_0: (+1)
   \        0xC   0x8802             LDRH     R2,[R0, #+0]
   \        0xE   0xF64F 0x71DF      MOVW     R1,#+65503
   \       0x12   0x....             B.N      ?Subroutine1
    789            }
    790          }
    791          
    792          /*******************************************************************************
    793          * Function Name  : I2C_GetPEC
    794          * Description    : Returns the PEC value for the specified I2C.
    795          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    796          * Output         : None
    797          * Return         : The PEC value.
    798          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    799          u8 I2C_GetPEC(I2C_TypeDef* I2Cx)
    800          {
    801            /* Check the parameters */
    802            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    803          
    804            /* Return the selected I2C PEC value */
    805            return ((I2Cx->SR2) >> 8);
   \                     I2C_GetPEC: (+1)
   \        0x0   0x8B00             LDRH     R0,[R0, #+24]
   \        0x2   0x0A00             LSRS     R0,R0,#+8
   \        0x4   0x4770             BX       LR               ;; return
    806          }
    807          
    808          /*******************************************************************************
    809          * Function Name  : I2C_ARPCmd
    810          * Description    : Enables or disables the specified I2C ARP.
    811          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    812          *                  - NewState: new state of the I2Cx ARP. 
    813          *                    This parameter can be: ENABLE or DISABLE.
    814          * Output         : None
    815          * Return         : None
    816          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    817          void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    818          {
    819            /* Check the parameters */
    820            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    821            assert_param(IS_FUNCTIONAL_STATE(NewState));
    822          
    823            if (NewState != DISABLE)
   \                     I2C_ARPCmd: (+1)
   \        0x0   0xB121             CBZ.N    R1,??I2C_ARPCmd_0
    824            {
    825              /* Enable the selected I2C ARP */
    826              I2Cx->CR1 |= CR1_ENARP_Set;
   \        0x2   0x8801             LDRH     R1,[R0, #+0]
   \        0x4   0xF041 0x0110      ORR      R1,R1,#0x10
   \        0x8   0x8001             STRH     R1,[R0, #+0]
   \        0xA   0x4770             BX       LR
    827            }
    828            else
    829            {
    830              /* Disable the selected I2C ARP */
    831              I2Cx->CR1 &= CR1_ENARP_Reset;
   \                     ??I2C_ARPCmd_0: (+1)
   \        0xC   0x8802             LDRH     R2,[R0, #+0]
   \        0xE   0xF64F 0x71EF      MOVW     R1,#+65519
   \       0x12   0x....             B.N      ?Subroutine1
    832            }
    833          }
    834          
    835          /*******************************************************************************
    836          * Function Name  : I2C_StretchClockCmd
    837          * Description    : Enables or disables the specified I2C Clock stretching.
    838          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    839          *                  - NewState: new state of the I2Cx Clock stretching.
    840          *                    This parameter can be: ENABLE or DISABLE.
    841          * Output         : None
    842          * Return         : None
    843          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    844          void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    845          {
    846            /* Check the parameters */
    847            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    848            assert_param(IS_FUNCTIONAL_STATE(NewState));
    849          
    850            if (NewState == DISABLE)
   \                     I2C_StretchClockCmd: (+1)
   \        0x0   0xB921             CBNZ.N   R1,??I2C_StretchClockCmd_0
    851            {
    852              /* Enable the selected I2C Clock stretching */
    853              I2Cx->CR1 |= CR1_NOSTRETCH_Set;
   \        0x2   0x8801             LDRH     R1,[R0, #+0]
   \        0x4   0xF041 0x0180      ORR      R1,R1,#0x80
   \        0x8   0x8001             STRH     R1,[R0, #+0]
   \        0xA   0x4770             BX       LR
    854            }
    855            else
    856            {
    857              /* Disable the selected I2C Clock stretching */
    858              I2Cx->CR1 &= CR1_NOSTRETCH_Reset;
   \                     ??I2C_StretchClockCmd_0: (+1)
   \        0xC   0x8802             LDRH     R2,[R0, #+0]
   \        0xE   0xF64F 0x717F      MOVW     R1,#+65407
   \       0x12   0x....             B.N      ?Subroutine1
    859            }
    860          }
    861          
    862          /*******************************************************************************
    863          * Function Name  : I2C_FastModeDutyCycleConfig
    864          * Description    : Selects the specified I2C fast mode duty cycle.
    865          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    866          *                  - I2C_DutyCycle: specifies the fast mode duty cycle.
    867          *                    This parameter can be one of the following values:
    868          *                       - I2C_DutyCycle_2: I2C fast mode Tlow/Thigh = 2
    869          *                       - I2C_DutyCycle_16_9: I2C fast mode Tlow/Thigh = 16/9
    870          * Output         : None
    871          * Return         : None
    872          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    873          void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, u16 I2C_DutyCycle)
    874          {
    875            /* Check the parameters */
    876            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    877            assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
    878          
    879            if (I2C_DutyCycle != I2C_DutyCycle_16_9)
   \                     I2C_FastModeDutyCycleConfig: (+1)
   \        0x0   0xF5B1 0x4F80      CMP      R1,#+16384
   \        0x4   0xD005             BEQ.N    ??I2C_FastModeDutyCycleConfig_0
    880            {
    881              /* I2C fast mode Tlow/Thigh=2 */
    882              I2Cx->CCR &= I2C_DutyCycle_2;
   \        0x6   0x8B82             LDRH     R2,[R0, #+28]
   \        0x8   0xF64B 0x71FF      MOVW     R1,#+49151
   \        0xC   0x400A             ANDS     R2,R1,R2
   \        0xE   0x8382             STRH     R2,[R0, #+28]
   \       0x10   0x4770             BX       LR
    883            }
    884            else
    885            {
    886              /* I2C fast mode Tlow/Thigh=16/9 */
    887              I2Cx->CCR |= I2C_DutyCycle_16_9;
   \                     ??I2C_FastModeDutyCycleConfig_0: (+1)
   \       0x12   0x8B81             LDRH     R1,[R0, #+28]
   \       0x14   0xF441 0x4180      ORR      R1,R1,#0x4000
   \       0x18   0x8381             STRH     R1,[R0, #+28]
    888            }
    889          }
   \       0x1A   0x4770             BX       LR               ;; return
    890          
    891          /*******************************************************************************
    892          * Function Name  : I2C_GetLastEvent
    893          * Description    : Returns the last I2Cx Event.
    894          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    895          * Output         : None
    896          * Return         : The last event
    897          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    898          u32 I2C_GetLastEvent(I2C_TypeDef* I2Cx)
    899          {
   \                     I2C_GetLastEvent: (+1)
   \        0x0   0x4601             MOV      R1,R0
    900            u32 lastevent = 0;
    901            u32 flag1 = 0, flag2 = 0;
    902          
    903            /* Check the parameters */
    904            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    905          
    906            /* Read the I2Cx status register */
    907            flag1 = I2Cx->SR1;
   \        0x2   0x8A88             LDRH     R0,[R1, #+20]
    908            flag2 = I2Cx->SR2;
   \        0x4   0x8B09             LDRH     R1,[R1, #+24]
    909            flag2 = flag2 << 16;
    910          
    911            /* Get the last event value from I2C status register */
    912            lastevent = (flag1 | flag2) & FLAG_Mask;
    913          
    914            /* Return status */
    915            return lastevent;
   \        0x6   0xEA40 0x4001      ORR      R0,R0,R1, LSL #+16
   \        0xA   0xF020 0x407F      BIC      R0,R0,#0xFF000000
   \        0xE   0x4770             BX       LR               ;; return
    916          }
    917          
    918          /*******************************************************************************
    919          * Function Name  : I2C_CheckEvent
    920          * Description    : Checks whether the last I2Cx Event is equal to the one passed
    921          *                  as parameter.
    922          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    923          *                  - I2C_EVENT: specifies the event to be checked. 
    924          *                    This parameter can be one of the following values:
    925          *                       - I2C_EVENT_SLAVE_ADDRESS_MATCHED   : EV1
    926          *                       - I2C_EVENT_SLAVE_BYTE_RECEIVED     : EV2
    927          *                       - I2C_EVENT_SLAVE_BYTE_TRANSMITTED  : EV3
    928          *                       - I2C_EVENT_SLAVE_ACK_FAILURE       : EV3-2
    929          *                       - I2C_EVENT_MASTER_MODE_SELECT      : EV5
    930          *                       - I2C_EVENT_MASTER_MODE_SELECTED    : EV6
    931          *                       - I2C_EVENT_MASTER_BYTE_RECEIVED    : EV7
    932          *                       - I2C_EVENT_MASTER_BYTE_TRANSMITTED : EV8
    933          *                       - I2C_EVENT_MASTER_MODE_ADDRESS10   : EV9
    934          *                       - I2C_EVENT_SLAVE_STOP_DETECTED     : EV4
    935          * Output         : None
    936          * Return         : An ErrorStatus enumuration value:
    937          *                       - SUCCESS: Last event is equal to the I2C_EVENT
    938          *                       - ERROR: Last event is different from the I2C_EVENT
    939          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    940          ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, u32 I2C_EVENT)
    941          {
   \                     I2C_CheckEvent: (+1)
   \        0x0   0x4602             MOV      R2,R0
    942            u32 lastevent = 0;
    943            u32 flag1 = 0, flag2 = 0;
    944            ErrorStatus status = ERROR;
   \        0x2   0x2000             MOVS     R0,#+0
    945          
    946            /* Check the parameters */
    947            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    948            assert_param(IS_I2C_EVENT(I2C_EVENT));
    949          
    950            /* Read the I2Cx status register */
    951            flag1 = I2Cx->SR1;
   \        0x4   0x8A93             LDRH     R3,[R2, #+20]
    952            flag2 = I2Cx->SR2;
   \        0x6   0x8B12             LDRH     R2,[R2, #+24]
    953            flag2 = flag2 << 16;
    954          
    955            /* Get the last event value from I2C status register */
    956            lastevent = (flag1 | flag2) & FLAG_Mask;
    957          
    958            /* Check whether the last event is equal to I2C_EVENT */
    959            if (lastevent == I2C_EVENT )
   \        0x8   0xEA43 0x4302      ORR      R3,R3,R2, LSL #+16
   \        0xC   0xF023 0x437F      BIC      R3,R3,#0xFF000000
   \       0x10   0x428B             CMP      R3,R1
   \       0x12   0xBF08             IT       EQ 
   \       0x14   0x2001             MOVEQ    R0,#+1
    960            {
    961              /* SUCCESS: last event is equal to I2C_EVENT */
    962              status = SUCCESS;
    963            }
    964            else
    965            {
    966              /* ERROR: last event is different from I2C_EVENT */
    967              status = ERROR;
    968            }
    969          
    970            /* Return status */
    971            return status;
   \       0x16   0x4770             BX       LR               ;; return
    972          }
    973          
    974          /*******************************************************************************
    975          * Function Name  : I2C_GetFlagStatus
    976          * Description    : Checks whether the specified I2C flag is set or not.
    977          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    978          *                  - I2C_FLAG: specifies the flag to check. 
    979          *                    This parameter can be one of the following values:
    980          *                       - I2C_FLAG_DUALF: Dual flag (Slave mode)
    981          *                       - I2C_FLAG_SMBHOST: SMBus host header (Slave mode)
    982          *                       - I2C_FLAG_SMBDEFAULT: SMBus default header (Slave mode)
    983          *                       - I2C_FLAG_GENCALL: General call header flag (Slave mode)
    984          *                       - I2C_FLAG_TRA: Transmitter/Receiver flag
    985          *                       - I2C_FLAG_BUSY: Bus busy flag
    986          *                       - I2C_FLAG_MSL: Master/Slave flag
    987          *                       - I2C_FLAG_SMBALERT: SMBus Alert flag
    988          *                       - I2C_FLAG_TIMEOUT: Timeout or Tlow error flag
    989          *                       - I2C_FLAG_PECERR: PEC error in reception flag
    990          *                       - I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode)
    991          *                       - I2C_FLAG_AF: Acknowledge failure flag
    992          *                       - I2C_FLAG_ARLO: Arbitration lost flag (Master mode)
    993          *                       - I2C_FLAG_BERR: Bus error flag
    994          *                       - I2C_FLAG_TXE: Data register empty flag (Transmitter)
    995          *                       - I2C_FLAG_RXNE: Data register not empty (Receiver) flag
    996          *                       - I2C_FLAG_STOPF: Stop detection flag (Slave mode)
    997          *                       - I2C_FLAG_ADD10: 10-bit header sent flag (Master mode)
    998          *                       - I2C_FLAG_BTF: Byte transfer finished flag
    999          *                       - I2C_FLAG_ADDR: Address sent flag (Master mode) ADSL
   1000          *                                        Address matched flag (Slave mode)ENDAD
   1001          *                       - I2C_FLAG_SB: Start bit flag (Master mode)
   1002          * Output         : None
   1003          * Return         : The new state of I2C_FLAG (SET or RESET).
   1004          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1005          FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, u32 I2C_FLAG)
   1006          {
   \                     I2C_GetFlagStatus: (+1)
   \        0x0   0x4602             MOV      R2,R0
   1007            FlagStatus bitstatus = RESET;
   \        0x2   0x2000             MOVS     R0,#+0
   1008            u32 i2cstatus = 0;
   1009            u32 flag1 = 0, flag2 = 0;
   1010          
   1011            /* Check the parameters */
   1012            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   1013            assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
   1014          
   1015            /* Read the I2Cx status register */
   1016            flag1 = I2Cx->SR1;
   \        0x4   0x8A93             LDRH     R3,[R2, #+20]
   1017            flag2 = I2Cx->SR2;
   \        0x6   0x8B12             LDRH     R2,[R2, #+24]
   1018            flag2 = (flag2 & FLAG_Mask) << 16;
   1019          
   1020            /* Get the I2C status value */
   1021            i2cstatus = flag1 | flag2;
   1022          
   1023            /* Get bit[23:0] of the flag */
   1024            I2C_FLAG &= FLAG_Mask;
   1025          
   1026            /* Check the status of the specified I2C flag */
   1027            if ((i2cstatus & I2C_FLAG) != (u32)RESET)
   \        0x8   0xEA43 0x4302      ORR      R3,R3,R2, LSL #+16
   \        0xC   0x4019             ANDS     R1,R1,R3
   \        0xE   0x0209             LSLS     R1,R1,#+8
   \       0x10   0xBF18             IT       NE 
   \       0x12   0x2001             MOVNE    R0,#+1
   1028            {
   1029              /* I2C_FLAG is set */
   1030              bitstatus = SET;
   1031            }
   1032            else
   1033            {
   1034              /* I2C_FLAG is reset */
   1035              bitstatus = RESET;
   1036            }
   1037            /* Return the I2C_FLAG status */
   1038            return  bitstatus;
   \       0x14   0x4770             BX       LR               ;; return
   1039          }
   1040          
   1041          /*******************************************************************************
   1042          * Function Name  : I2C_ClearFlag
   1043          * Description    : Clears the I2Cx's pending flags.
   1044          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
   1045          *                  - I2C_FLAG: specifies the flag to clear. 
   1046          *                    This parameter can be one of the following values:
   1047          *                       - I2C_FLAG_SMBALERT: SMBus Alert flag
   1048          *                       - I2C_FLAG_TIMEOUT: Timeout or Tlow error flag
   1049          *                       - I2C_FLAG_PECERR: PEC error in reception flag
   1050          *                       - I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode)
   1051          *                       - I2C_FLAG_AF: Acknowledge failure flag
   1052          *                       - I2C_FLAG_ARLO: Arbitration lost flag (Master mode)
   1053          *                       - I2C_FLAG_BERR: Bus error flag
   1054          *                       - I2C_FLAG_STOPF: Stop detection flag (Slave mode)
   1055          *                       - I2C_FLAG_ADD10: 10-bit header sent flag (Master mode)
   1056          *                       - I2C_FLAG_BTF: Byte transfer finished flag
   1057          *                       - I2C_FLAG_ADDR: Address sent flag (Master mode) ADSL
   1058          *                                        Address matched flag (Slave mode)ENDAD
   1059          *                       - I2C_FLAG_SB: Start bit flag (Master mode)
   1060          * Output         : None
   1061          * Return         : None
   1062          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1063          void I2C_ClearFlag(I2C_TypeDef* I2Cx, u32 I2C_FLAG)
   1064          {
   1065            u32 flagpos = 0;
   1066            u32 flagindex = 0;
   1067          
   1068            /* Check the parameters */
   1069            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   1070            assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
   1071          
   1072            /* Get the I2C flag position */
   1073            flagpos = I2C_FLAG & FLAG_Mask;
   1074          
   1075            /* Get the I2C flag index */
   1076            flagindex = I2C_FLAG >> 28;
   \                     I2C_ClearFlag: (+1)
   \        0x0   0x0F0A             LSRS     R2,R1,#+28
   1077          
   1078            /* Clear the flag by writing 0 */
   1079            if (flagindex == 1)
   \        0x2   0x2A01             CMP      R2,#+1
   \        0x4   0xD100             BNE.N    ??I2C_ClearFlag_0
   1080            {
   1081              /* Clear the selected I2C flag */
   1082              I2Cx->SR1 = (u16)~flagpos;
   \        0x6   0x....             B.N      ?Subroutine3
   1083            }
   1084            /* Flags that need a read of the SR1 register to be cleared */
   1085            else if (flagindex == 2)
   \                     ??I2C_ClearFlag_0: (+1)
   \        0x8   0x2A02             CMP      R2,#+2
   \        0xA   0xD101             BNE.N    ??I2C_ClearFlag_1
   1086            {
   1087              /* Read the SR1 register */
   1088              (void)I2Cx->SR1;
   \        0xC   0x8A80             LDRH     R0,[R0, #+20]
   \        0xE   0x4770             BX       LR
   1089            }
   1090            /* Flags that need a read of SR1 and a write on CR1 registers to be cleared */
   1091            else if (flagindex == 6)
   \                     ??I2C_ClearFlag_1: (+1)
   \       0x10   0x2A06             CMP      R2,#+6
   \       0x12   0x8A81             LDRH     R1,[R0, #+20]
   \       0x14   0xD100             BNE.N    ??I2C_ClearFlag_2
   1092            {
   1093              /* Read the SR1 register */
   1094              (void)I2Cx->SR1;
   1095          
   1096              /* Write on the CR1 register */
   1097              I2Cx->CR1 |= CR1_PE_Set;
   \       0x16   0x....             B.N      ?Subroutine0
   1098            }
   1099            /* Flags that need a read of SR1 and SR2 registers to be cleared */
   1100            else /*flagindex == 0xA*/
   1101            {
   1102              /* Read the SR1 register */
   1103              (void)I2Cx->SR1;
   1104          
   1105              /* Read the SR2 register */
   1106              (void)I2Cx->SR2;
   \                     ??I2C_ClearFlag_2: (+1)
   \       0x18   0x8B00             LDRH     R0,[R0, #+24]
   1107            }
   1108          }
   \       0x1A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0x43C9             MVNS     R1,R1
   \        0x2   0x8281             STRH     R1,[R0, #+20]
   \        0x4   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x8802             LDRH     R2,[R0, #+0]
   \        0x2   0xF042 0x0201      ORR      R2,R2,#0x1
   \        0x6   0x8002             STRH     R2,[R0, #+0]
   \        0x8   0x4770             BX       LR
   1109          
   1110          /*******************************************************************************
   1111          * Function Name  : I2C_GetITStatus
   1112          * Description    : Checks whether the specified I2C interrupt has occurred or not.
   1113          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
   1114          *                  - I2C_IT: specifies the interrupt source to check. 
   1115          *                    This parameter can be one of the following values:
   1116          *                       - I2C_IT_SMBALERT: SMBus Alert flag
   1117          *                       - I2C_IT_TIMEOUT: Timeout or Tlow error flag
   1118          *                       - I2C_IT_PECERR: PEC error in reception flag
   1119          *                       - I2C_IT_OVR: Overrun/Underrun flag (Slave mode)
   1120          *                       - I2C_IT_AF: Acknowledge failure flag
   1121          *                       - I2C_IT_ARLO: Arbitration lost flag (Master mode)
   1122          *                       - I2C_IT_BERR: Bus error flag
   1123          *                       - I2C_IT_TXE: Data register empty flag (Transmitter)
   1124          *                       - I2C_IT_RXNE: Data register not empty (Receiver) flag
   1125          *                       - I2C_IT_STOPF: Stop detection flag (Slave mode)
   1126          *                       - I2C_IT_ADD10: 10-bit header sent flag (Master mode)
   1127          *                       - I2C_IT_BTF: Byte transfer finished flag
   1128          *                       - I2C_IT_ADDR: Address sent flag (Master mode) ADSL
   1129          *                                        Address matched flag (Slave mode)ENDAD
   1130          *                       - I2C_IT_SB: Start bit flag (Master mode)
   1131          * Output         : None
   1132          * Return         : The new state of I2C_IT (SET or RESET).
   1133          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1134          ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, u32 I2C_IT)
   1135          {
   \                     I2C_GetITStatus: (+1)
   \        0x0   0x4602             MOV      R2,R0
   1136            ITStatus bitstatus = RESET;
   \        0x2   0x2000             MOVS     R0,#+0
   1137            u32 i2cstatus = 0;
   1138            u32 flag1 = 0, flag2 = 0;
   1139          
   1140            /* Check the parameters */
   1141            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   1142            assert_param(IS_I2C_GET_IT(I2C_IT));
   1143          
   1144            /* Read the I2Cx status register */
   1145            flag1 = I2Cx->SR1;
   \        0x4   0x8A93             LDRH     R3,[R2, #+20]
   1146            flag2 = I2Cx->SR2;
   \        0x6   0x8B12             LDRH     R2,[R2, #+24]
   1147            flag2 = (flag2 & FLAG_Mask) << 16;
   1148          
   1149            /* Get the I2C status value */
   1150            i2cstatus = flag1 | flag2;
   1151          
   1152            /* Get bit[23:0] of the flag */
   1153            I2C_IT &= FLAG_Mask;
   1154          
   1155            /* Check the status of the specified I2C flag */
   1156            if ((i2cstatus & I2C_IT) != (u32)RESET)
   \        0x8   0xEA43 0x4302      ORR      R3,R3,R2, LSL #+16
   \        0xC   0x4019             ANDS     R1,R1,R3
   \        0xE   0x0209             LSLS     R1,R1,#+8
   \       0x10   0xBF18             IT       NE 
   \       0x12   0x2001             MOVNE    R0,#+1
   1157            {
   1158              /* I2C_IT is set */
   1159              bitstatus = SET;
   1160            }
   1161            else
   1162            {
   1163              /* I2C_IT is reset */
   1164              bitstatus = RESET;
   1165            }
   1166            /* Return the I2C_IT status */
   1167            return  bitstatus;
   \       0x14   0x4770             BX       LR               ;; return
   1168          }
   1169          
   1170          /*******************************************************************************
   1171          * Function Name  : I2C_ClearITPendingBit
   1172          * Description    : Clears the I2Cxs interrupt pending bits.
   1173          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
   1174          *                  - I2C_IT: specifies the interrupt pending bit to clear. 
   1175          *                    This parameter can be one of the following values:
   1176          *                       - I2C_IT_SMBALERT: SMBus Alert flag
   1177          *                       - I2C_IT_TIMEOUT: Timeout or Tlow error flag
   1178          *                       - I2C_IT_PECERR: PEC error in reception flag
   1179          *                       - I2C_IT_OVR: Overrun/Underrun flag (Slave mode)
   1180          *                       - I2C_IT_AF: Acknowledge failure flag
   1181          *                       - I2C_IT_ARLO: Arbitration lost flag (Master mode)
   1182          *                       - I2C_IT_BERR: Bus error flag
   1183          *                       - I2C_IT_STOPF: Stop detection flag (Slave mode)
   1184          *                       - I2C_IT_ADD10: 10-bit header sent flag (Master mode)
   1185          *                       - I2C_IT_BTF: Byte transfer finished flag
   1186          *                       - I2C_IT_ADDR: Address sent flag (Master mode) ADSL
   1187          *                                        Address matched flag (Slave mode)ENDAD
   1188          *                       - I2C_IT_SB: Start bit flag (Master mode)
   1189          * Output         : None
   1190          * Return         : None
   1191          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1192          void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, u32 I2C_IT)
   1193          {
   1194            u32 flagpos = 0;
   1195            u32 flagindex = 0;
   1196          
   1197            /* Check the parameters */
   1198            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   1199            assert_param(IS_I2C_CLEAR_IT(I2C_IT));
   1200          
   1201            /* Get the I2C flag position */
   1202            flagpos = I2C_IT & FLAG_Mask;
   1203          
   1204            /* Get the I2C flag index */
   1205            flagindex = I2C_IT >> 28;
   \                     I2C_ClearITPendingBit: (+1)
   \        0x0   0x0F0A             LSRS     R2,R1,#+28
   1206          
   1207            /* Clear the flag by writing 0 */
   1208            if (flagindex == 1)
   \        0x2   0x2A01             CMP      R2,#+1
   \        0x4   0xD100             BNE.N    ??I2C_ClearITPendingBit_0
   1209            {
   1210              /* Clear the selected I2C flag */
   1211              I2Cx->SR1 = (u16)~flagpos;
   \        0x6   0x....             B.N      ?Subroutine3
   1212            }
   1213            /* Flags that need a read of the SR1 register to be cleared */
   1214            else if (flagindex == 2)
   \                     ??I2C_ClearITPendingBit_0: (+1)
   \        0x8   0x2A02             CMP      R2,#+2
   \        0xA   0xD101             BNE.N    ??I2C_ClearITPendingBit_1
   1215            {
   1216              /* Read the SR1 register */
   1217              (void)I2Cx->SR1;
   \        0xC   0x8A80             LDRH     R0,[R0, #+20]
   \        0xE   0x4770             BX       LR
   1218            }
   1219            /* Flags that need a read of SR1 and a write on CR1 registers to be cleared */
   1220            else if (flagindex == 6)
   \                     ??I2C_ClearITPendingBit_1: (+1)
   \       0x10   0x2A06             CMP      R2,#+6
   \       0x12   0x8A81             LDRH     R1,[R0, #+20]
   \       0x14   0xD100             BNE.N    ??I2C_ClearITPendingBit_2
   1221            {
   1222              /* Read the SR1 register */
   1223              (void)I2Cx->SR1;
   1224          
   1225              /* Write on the CR1 register */
   1226              I2Cx->CR1 |= CR1_PE_Set;
   \       0x16   0x....             B.N      ?Subroutine0
   1227            }
   1228            /* Flags that need a read of SR1 and SR2 registers to be cleared */
   1229            else /*flagindex == 0xA*/
   1230            {
   1231              /* Read the SR1 register */
   1232              (void)I2Cx->SR1;
   1233          
   1234              /* Read the SR2 register */
   1235              (void)I2Cx->SR2;
   \                     ??I2C_ClearITPendingBit_2: (+1)
   \       0x18   0x8B00             LDRH     R0,[R0, #+24]
   1236            }
   1237          }
   \       0x1A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \        0x0   0x4000'5400        DC32     0x40005400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \        0x0   0x4000'5800        DC32     0x40005800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \        0x0   0x000F'4240        DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_3:
   \        0x0   0x0001'86A1        DC32     0x186a1
   1238          
   1239          /******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   I2C_ARPCmd
       0   I2C_AcknowledgeConfig
       0   I2C_CalculatePEC
       0   I2C_CheckEvent
       0   I2C_ClearFlag
       0   I2C_ClearITPendingBit
       0   I2C_Cmd
       0   I2C_DMACmd
       0   I2C_DMALastTransferCmd
       8   I2C_DeInit
         0   -> RCC_APB1PeriphResetCmd
         8   -> RCC_APB1PeriphResetCmd
       0   I2C_DualAddressCmd
       0   I2C_FastModeDutyCycleConfig
       0   I2C_GeneralCallCmd
       0   I2C_GenerateSTART
       0   I2C_GenerateSTOP
       0   I2C_GetFlagStatus
       0   I2C_GetITStatus
       0   I2C_GetLastEvent
       0   I2C_GetPEC
       0   I2C_ITConfig
      40   I2C_Init
        40   -> RCC_GetClocksFreq
       0   I2C_OwnAddress2Config
       0   I2C_PECPositionConfig
       0   I2C_ReadRegister
       0   I2C_ReceiveData
       0   I2C_SMBusAlertConfig
       0   I2C_Send7bitAddress
       0   I2C_SendData
       0   I2C_SoftwareResetCmd
       0   I2C_StretchClockCmd
       0   I2C_StructInit
       0   I2C_TransmitPEC


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
       4  ??DataTable1_3
      10  ?Subroutine0
       6  ?Subroutine1
       6  ?Subroutine2
       6  ?Subroutine3
      20  I2C_ARPCmd
      20  I2C_AcknowledgeConfig
      20  I2C_CalculatePEC
      24  I2C_CheckEvent
      28  I2C_ClearFlag
      28  I2C_ClearITPendingBit
      20  I2C_Cmd
      20  I2C_DMACmd
      18  I2C_DMALastTransferCmd
      58  I2C_DeInit
      24  I2C_DualAddressCmd
      28  I2C_FastModeDutyCycleConfig
      20  I2C_GeneralCallCmd
      18  I2C_GenerateSTART
      20  I2C_GenerateSTOP
      22  I2C_GetFlagStatus
      22  I2C_GetITStatus
      16  I2C_GetLastEvent
       6  I2C_GetPEC
      16  I2C_ITConfig
     174  I2C_Init
      18  I2C_OwnAddress2Config
      24  I2C_PECPositionConfig
       6  I2C_ReadRegister
       6  I2C_ReceiveData
      24  I2C_SMBusAlertConfig
      16  I2C_Send7bitAddress
       4  I2C_SendData
      22  I2C_SoftwareResetCmd
      20  I2C_StretchClockCmd
      28  I2C_StructInit
      20  I2C_TransmitPEC

 
 854 bytes in section .text
 
 854 bytes of CODE memory

Errors: none
Warnings: none
